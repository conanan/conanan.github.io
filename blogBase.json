{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Blog Title", "subTitle": "Blog description", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/Imaris wrl struct for dendrite annotaion.html", "labels": ["documentation"], "postTitle": "Imaris wrl struct for dendrite annotaion", "postUrl": "post/Imaris%20wrl%20struct%20for%20dendrite%20annotaion.html", "postSourceUrl": "https://github.com/conanan/conanan.github.io/issues/1", "commentNum": 2, "wordCount": 5356, "description": "\n***\n\n## **Annotated WRL Structure for FilamentSegment510000000001**\n\n```wrl\nDEF FilamentSegment510000000001   Group {\n  # This is the main container for one dendrite segment\n  # 'DEF' gives it a unique identifier (name)\n  # 'Group' means it can hold multiple children (sub-elements)\n  \n  children [\n    # List of child nodes under this segment\n    \n    DEF _4   Group {\n      # Empty group (placeholder)\n      # May be reserved for centerline, annotations, or future data\n    },\n    \n    DEF _5   Group {\n      # This group contains the visible 3D mesh (surface geometry)\n      \n      children\n        DEF _6   Shape {\n          # 'Shape' is the actual 3D object that gets rendered\n          # Contains appearance (color/material) and geometry (mesh)\n          \n          appearance\n            Appearance {\n              # Defines how the surface looks (color, shine, texture)\n              \n              material\n                Material {\n                  # Material properties for lighting and color\n                  \n                  diffuseColor 0.80000001 0 0.80000001\n                  # RGB color: (0.8, 0, 0.8) = Purple/Magenta\n                  # This typically identifies the dendrite shaft\n                  # (Spines are usually red: 1 0 0)\n                  \n                  specularColor 0.30000001 0.30000001 0.30000001\n                  # Specular (shininess) color: light gray\n                  # Controls how shiny/reflective the surface appears\n                }\n            }\n          \n          geometry\n            IndexedFaceSet {\n              # This defines the mesh surface as a collection of polygonal faces\n              # Each face is a flat panel connecting 3+ points\n              \n              coord\n                Coordinate {\n                  # Container for all 3D vertex positions\n                  \n                  point [ 10.075352 16.53404 7.1640425, ... ]\n                  # List of all (x, y, z) coordinates\n                  # Each triplet is one vertex in 3D space\n                  # For a tube/dendrite: points are arranged in rings (cross-sections)\n                  # These coordinates define the exact shape and position\n                }\n              \n              texCoord ...\n              # Texture coordinates (for applying images/patterns to surface)\n              # Not needed for morphometric measurements\n              \n              normal ...\n              # Surface normal vectors (for lighting calculations)\n              # Each normal points perpendicular to the surface at each vertex\n              # Used for realistic shading\n              \n              coordIndex [ 0, 1, 18, 17, -1, 1, 2, 19, 18, -1, ... ]\n              # THE KEY CONNECTIVITY ARRAY\n              # Defines which points form each face (polygon)\n              # Format: [point_a, point_b, point_c, point_d, -1, ...]\n              #   - Each group of indices (before -1) forms one face\n              #   - '-1' is a separator (end of face)\n              # Example: [0, 1, 18, 17, -1] connects points 0\u21921\u219218\u219217 into a quad\n              # For tubes: connects two neighboring rings to form surface panels\n              \n              normalIndex [ 0, 1, 18, 17, -1, 1, 2, 19, 18, -1, ... ]\n              # Same structure as coordIndex, but for normal vectors\n              # Parallel array for shading\n              \n              texCoordIndex [ 0, 1, 18, 17, -1, 1, 2, 19, 18, -1, ... ]\n              # Same structure, for texture mapping\n              # Parallel array for texture coordinates\n              \n              ccw TRUE\n              # 'Counter-clockwise' vertex ordering\n              # Determines which side of the face is 'front' (visible)\n              # TRUE = vertices listed in counter-clockwise order when viewed from outside\n              \n              solid FALSE\n              # FALSE = render both sides of each face\n              # (Not a 'solid' object\u2014both inside and outside are visible)\n              \n              convex TRUE\n              # All faces are convex (no dents/concave parts)\n              # Optimization hint for renderer\n              \n              creaseAngle 0\n              # Shading smoothness threshold (in radians)\n              # 0 = sharp edges (flat shading between faces)\n              # Higher values = smooth shading across edges\n            }\n        }\n    },\n    \n    DEF _7   Group {\n      # Another empty group (reserved/unused)\n      # May hold metadata, labels, or future extensions\n    }\n  ]\n}\n```\n\n\n***\n\n## **Visual Breakdown**\n\n```\nFilamentSegment510000000001 (the dendrite segment container)\n\u2502\n\u251c\u2500 _4 (empty placeholder group)\n\u2502\n\u251c\u2500 _5 (group holding the 3D mesh)\n\u2502   \u2502\n\u2502   \u2514\u2500 _6 (Shape = the visible surface)\n\u2502       \u2502\n\u2502       \u251c\u2500 Appearance\n\u2502       \u2502   \u2514\u2500 Material\n\u2502       \u2502       \u251c\u2500 diffuseColor: 0.8 0 0.8 (purple = dendrite)\n\u2502       \u2502       \u2514\u2500 specularColor: 0.3 0.3 0.3 (shininess)\n\u2502       \u2502\n\u2502       \u2514\u2500 IndexedFaceSet (the mesh geometry)\n\u2502           \u251c\u2500 Coordinate\n\u2502           \u2502   \u2514\u2500 point [ x y z, ... ]  \u2190 ALL vertex positions\n\u2502           \u251c\u2500 coordIndex [ ... ]        \u2190 HOW to connect vertices into faces\n\u2502           \u251c\u2500 normalIndex [ ... ]       \u2190 Normals for shading\n\u2502           \u251c\u2500 texCoordIndex [ ... ]     \u2190 Texture mapping\n\u2502           \u2514\u2500 Rendering flags (ccw, solid, convex, creaseAngle)\n\u2502\n\u2514\u2500 _7 (empty placeholder group)\n```\n\n\n\u3002", "top": 0, "createdAt": 1764148838, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-11-26", "dateLabelColor": "#0969da"}, "P4": {"htmlDir": "docs/post/draw wrl with vtk.html", "labels": ["documentation"], "postTitle": "draw wrl with vtk", "postUrl": "post/draw%20wrl%20with%20vtk.html", "postSourceUrl": "https://github.com/conanan/conanan.github.io/issues/4", "commentNum": 1, "wordCount": 20189, "description": "# point\n```\nimport vtk\nimport re\nimport numpy as np\n\n# -------------------------- \u914d\u7f6e\u53c2\u6570\uff08\u65b0\u589e\u70b9\u5927\u5c0f\u8bbe\u7f6e\uff09 --------------------------\nVRML_FILE_PATH = r'C:\\Users\\liuj2\\Desktop\\10_PDGF x GFP-M#170_Control RH_01x.wrl'\nPOINT_SIZE = 5.0  # \u9876\u70b9\u5927\u5c0f\uff08\u53ef\u8c03\u6574\uff0c\u8d8a\u5927\u8d8a\u6e05\u6670\uff09\nBACKGROUND_COLOR = (1.0, 1.0, 1.0)  # \u767d\u8272\u80cc\u666f\n\n# -------------------------- \u6838\u5fc3\u5de5\u5177\uff1a\u89e3\u6790\u903b\u8f91\u4e0d\u53d8\uff08\u4ecd\u63d0\u53d6\u9876\u70b9\u6570\u636e\uff09 --------------------------\ndef parse_vrml_manual(vrml_path):\n    '''\u624b\u52a8\u89e3\u6790VRML\uff0c\u63d0\u53d6\u9876\u70b9\u3001\u989c\u8272\u7b49\u6570\u636e\uff08\u89e3\u6790\u903b\u8f91\u4e0d\u53d8\uff09'''\n    with open(vrml_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    # \u6b63\u5219\u5339\u914d\u6838\u5fc3\u6570\u636e\uff08FilamentSegment \u2192 \u989c\u8272 \u2192 \u9876\u70b9 \u2192 \u7d22\u5f15\uff09\n    pattern = r'''\n        DEF\\s+(FilamentSegment\\d+)\\s+Group\\s*\\{\\s*\n        .*?diffuseColor\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s*\n        .*?point\\s*\\[\\s*(.*?)\\s*\\]\n        .*?coordIndex\\s*\\[\\s*(.*?)\\s*\\]\n    '''\n    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)\n    \n    if not matches:\n        print('\u26a0\ufe0f  \u672a\u5339\u914d\u5230FilamentSegment\u6570\u636e\uff0c\u5c1d\u8bd5\u7b80\u5316\u5339\u914d\u89c4\u5219...')\n        pattern_simple = r'DEF\\s+(FilamentSegment\\d+)\\s+Group\\s*\\{\\s*.*?diffuseColor\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*.*?point\\s*\\[\\s*(.*?)\\s*\\]'\n        matches = re.findall(pattern_simple, content, re.DOTALL)\n    \n    parsed_data = []\n    for match in matches:\n        # \u89e3\u5305\u5339\u914d\u7ed3\u679c\uff08\u517c\u5bb9\u5b8c\u6574/\u7b80\u5316\u6b63\u5219\uff09\n        if len(match) == 6:\n            seg_id, r, g, b, point_str, coord_idx_str = match\n        else:\n            seg_id, r, g, b, point_str = match\n            coord_idx_str = ''\n        \n        # \u89e3\u6790\u989c\u8272\uff08\u8f6c\u4e3aVTK\u6240\u9700\u76840-255\u6574\u6570\uff09\n        r, g, b = float(r), float(g), float(b)\n        if r > 0.7 and g < 0.1 and b > 0.7:\n            rgb = (192, 0, 192)  # \u6811\u7a81\uff08\u7d2b\u8272\uff09\n        elif r > 0.9 and g < 0.1 and b < 0.1:\n            rgb = (255, 0, 0)    # \u810a\u67f1\uff08\u7ea2\u8272\uff09\n        else:\n            rgb = (128, 128, 128)  # \u5176\u4ed6\u7ed3\u6784\uff08\u7070\u8272\uff09\n        \n        # \u89e3\u6790\u9876\u70b9\u5750\u6807\uff08\u8f6c\u4e3a(n,3)\u6570\u7ec4\uff09\n        points = re.findall(r'[-+]?\\d+\\.?\\d*e?[-+]?\\d*', point_str)\n        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])\n        \n        # \u4ec5\u4fdd\u7559\u6709\u9876\u70b9\u7684\u6570\u636e\uff08\u81f3\u5c111\u4e2a\u9876\u70b9\u5373\u53ef\uff09\n        if len(points) >= 1:\n            parsed_data.append({\n                'seg_id': seg_id,\n                'rgb': rgb,\n                'points': points\n            })\n    \n    return parsed_data\n\n# -------------------------- \u6838\u5fc3\u903b\u8f91\uff1a\u4ec5\u6e32\u67d3\u9876\u70b9\uff08\u4e0d\u8fde\u63a5\u7ebf\u6bb5\uff09 --------------------------\ndef vtk_render_points_only(parsed_data):\n    '''\u7eaf\u9876\u70b9\u6e32\u67d3\uff0c\u4e0d\u6784\u5efa\u4efb\u4f55\u7ebf\u6bb5'''\n    vtk_poly_data = vtk.vtkPolyData()\n    vtk_points = vtk.vtkPoints()\n    vtk_vertices = vtk.vtkCellArray()  # \u7528\u4e8e\u5b58\u50a8\u9876\u70b9\uff08\u66ff\u6362\u539f\u6765\u7684vtkLines\uff09\n    color_map = vtk.vtkUnsignedCharArray()\n    color_map.SetNumberOfComponents(3)\n    color_map.SetName('Colors')\n\n    # \u904d\u5386\u89e3\u6790\u6570\u636e\uff0c\u6dfb\u52a0\u6240\u6709\u9876\u70b9\uff08\u4e0d\u5904\u7406\u8fde\u63a5\u5173\u7cfb\uff09\n    for seg in parsed_data:\n        points = seg['points']\n        rgb = seg['rgb']\n\n        # \u9010\u4e2a\u6dfb\u52a0\u9876\u70b9\u548c\u5bf9\u5e94\u7684\u989c\u8272\n        for x, y, z in points:\n            # \u6dfb\u52a0\u9876\u70b9\u5750\u6807\n            point_id = vtk_points.InsertNextPoint(x, y, z)\n            # \u6dfb\u52a0\u9876\u70b9\u989c\u8272\n            color_map.InsertNextTuple3(*rgb)\n            # \u521b\u5efa\u5355\u4e2a\u9876\u70b9\u5355\u5143\uff08\u5173\u952e\uff1a\u6bcf\u4e2a\u70b9\u4f5c\u4e3a\u72ec\u7acb\u5355\u5143\uff09\n            vertex = vtk.vtkVertex()\n            vertex.GetPointIds().SetId(0, point_id)\n            vtk_vertices.InsertNextCell(vertex)\n\n    # \u7ec4\u88c5VTK\u6570\u636e\uff08\u7528\u9876\u70b9\u5355\u5143\u66ff\u6362\u7ebf\u6bb5\u5355\u5143\uff09\n    vtk_poly_data.SetPoints(vtk_points)\n    vtk_poly_data.SetVerts(vtk_vertices)  # \u6e32\u67d3\u9876\u70b9\uff08\u66ff\u6362\u539f\u6765\u7684SetLines\uff09\n    vtk_poly_data.GetPointData().SetScalars(color_map)\n\n    # \u914d\u7f6eVTK\u6e32\u67d3\u7ba1\u7ebf\uff08\u91cd\u70b9\u8bbe\u7f6e\u70b9\u5927\u5c0f\uff09\n    mapper = vtk.vtkPolyDataMapper()\n    mapper.SetInputData(vtk_poly_data)\n    mapper.ScalarVisibilityOn()  # \u542f\u7528\u989c\u8272\u6620\u5c04\n\n    actor = vtk.vtkActor()\n    actor.SetMapper(mapper)\n    actor.GetProperty().SetPointSize(POINT_SIZE)  # \u8bbe\u7f6e\u9876\u70b9\u5927\u5c0f\uff08\u6838\u5fc3\u4fee\u6539\uff09\n\n    # \u6e32\u67d3\u5668\u914d\u7f6e\n    renderer = vtk.vtkRenderer()\n    renderer.AddActor(actor)\n    renderer.SetBackground(*BACKGROUND_COLOR)\n    renderer.ResetCamera()  # \u81ea\u52a8\u8c03\u6574\u89c6\u89d2\u4ee5\u5305\u542b\u6240\u6709\u70b9\n\n    # \u7a97\u53e3\u914d\u7f6e\n    render_window = vtk.vtkRenderWindow()\n    render_window.SetWindowName('\u795e\u7ecf\u7ec6\u4e1d\u9876\u70b9\u53ef\u89c6\u5316\uff08\u4ec5\u663e\u793a\u70b9\uff09')\n    render_window.SetSize(1200, 900)\n    render_window.AddRenderer(renderer)\n\n    # \u4ea4\u4e92\u5668\u914d\u7f6e\n    interactor = vtk.vtkRenderWindowInteractor()\n    interactor.SetRenderWindow(render_window)\n\n    # \u542f\u52a8\u53ef\u89c6\u5316\n    interactor.Initialize()\n    render_window.Render()\n    print('\ud83d\uddb1\ufe0f  \u4ea4\u4e92\u6307\u5357\uff1a')\n    print('   - \u5de6\u952e\u62d6\u62fd\uff1a\u65cb\u8f6c\u573a\u666f')\n    print('   - \u6eda\u8f6e\uff1a\u7f29\u653e\u753b\u9762')\n    print('   - \u53f3\u952e\u62d6\u62fd\uff1a\u5e73\u79fb\u573a\u666f')\n    print('   - \u6309 'q' \u952e\u5173\u95ed\u7a97\u53e3')\n    interactor.Start()\n\n# -------------------------- \u4e3b\u6267\u884c\u6d41\u7a0b --------------------------\n# 1. \u89e3\u6790VRML\uff08\u63d0\u53d6\u9876\u70b9\u6570\u636e\uff09\nprint('\ud83d\udce5 \u6b63\u5728\u89e3\u6790VRML\u6587\u4ef6...')\nparsed_data = parse_vrml_manual(VRML_FILE_PATH)\n\nif not parsed_data:\n    print('\u274c \u672a\u63d0\u53d6\u5230\u6709\u6548\u9876\u70b9\u6570\u636e\uff01')\nelse:\n    # \u7edf\u8ba1\u603b\u9876\u70b9\u6570\n    total_points = sum(len(seg['points']) for seg in parsed_data)\n    print(f'\u2705 \u6210\u529f\u89e3\u6790 {len(parsed_data)} \u4e2a\u7ebf\u6bb5\uff0c\u5171 {total_points} \u4e2a\u9876\u70b9\uff0c\u542f\u52a8\u9876\u70b9\u53ef\u89c6\u5316...')\n    # 2. \u4ec5\u6e32\u67d3\u9876\u70b9\n    vtk_render_points_only(parsed_data)\n```\n\n\n\n# lines\n\n```import re\nimport numpy as np\nimport json\nfrom pathlib import Path\nimport os\n\n# -------------------------- \u914d\u7f6e\u53c2\u6570 --------------------------\nVRML_FILE_PATH = r'C:\\Users\\liuj2\\Desktop\\10_PDGF x GFP-M#170_Control RH_01x.wrl'\nEXPORT_FORMAT = 'json'  # \u5bfc\u51fa\u683c\u5f0f\uff1a'json'\uff08\u63a8\u8350\uff0c\u4fdd\u7559\u7ed3\u6784\uff09\u6216 'txt'\uff08\u6613\u8bfb\uff09\nDEFAULT_COLOR = (128, 128, 128)  # \u65e0diffuseColor\u65f6\u7684\u9ed8\u8ba4\u989c\u8272\n\n# -------------------------- \u6838\u5fc3\u89e3\u6790\u51fd\u6570\uff08\u4fdd\u7559\u6240\u6709\u7279\u5f81\uff09 --------------------------\ndef parse_vrml_manual(vrml_path):\n    '''\u89e3\u6790VRML\uff0c\u63d0\u53d6\u6240\u6709FilamentSegment\u7684\u5b8c\u6574\u7279\u5f81\uff08\u9002\u914dIndexedFaceSet\u7ed3\u6784\uff09'''\n    with open(vrml_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    # \u7cbe\u51c6\u5339\u914d\uff1aFilamentSegment \u2192 diffuseColor \u2192 IndexedFaceSet \u2192 Coordinate(point) + coordIndex\n    pattern = r'''\n        DEF\\s+(FilamentSegment\\d+)\\s+Group\\s*\\{\\s*\n        .*?\n        (diffuseColor\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s*)?  # \u989c\u8272\uff08\u53ef\u9009\uff09\n        .*?\n        IndexedFaceSet\\s*\\{\\s*\n        .*?\n        (coord\\s+DEF\\s+(\\w+)\\s+Coordinate\\s*\\{\\s*point\\s*\\[\\s*(.*?)\\s*\\]\\s*\\}\\s*)  # Coordinate\u8282\u70b9\uff08\u542bpoint\uff09\n        .*?\n        (normal\\s+DEF\\s+(\\w+)\\s+Normal\\s*\\{\\s*vector\\s*(.*?)\\s*\\}\\s*)?  # Normal\u8282\u70b9\uff08\u53ef\u9009\uff0c\u542b\u6cd5\u5411\u91cf\uff09\n        .*?\n        (coordIndex\\s*\\[\\s*(.*?)\\s*\\])  # coordIndex\uff08\u9762\u7d22\u5f15\uff09\n        .*?\n        (normalIndex\\s*\\[\\s*(.*?)\\s*\\])?  # normalIndex\uff08\u53ef\u9009\uff09\n        .*?\n        (ccw\\s+(\\w+))?\\s*  # ccw\u53c2\u6570\uff08\u53ef\u9009\uff09\n        (solid\\s+(\\w+))?\\s*  # solid\u53c2\u6570\uff08\u53ef\u9009\uff09\n        (convex\\s+(\\w+))?\\s*  # convex\u53c2\u6570\uff08\u53ef\u9009\uff09\n        (creaseAngle\\s+(\\d+\\.?\\d*))?\\s*  # creaseAngle\u53c2\u6570\uff08\u53ef\u9009\uff09\n        .*?\\}\\s*  # \u5173\u95edIndexedFaceSet\n        .*?\\}\\s*  # \u5173\u95edFilamentSegment Group\n    '''\n    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE | re.IGNORECASE)\n    \n    parsed_data = []\n    for match in matches:\n        # \u89e3\u5305\u5339\u914d\u7ed3\u679c\uff08\u6309\u6b63\u5219\u5206\u7ec4\u987a\u5e8f\uff09\n        (diffuseColor_block, r, g, b,\n         coord_block, coord_def_id, point_str,\n         normal_block, normal_def_id, normal_vector_str,\n         coordIndex_block, coord_idx_str,\n         normalIndex_block, normal_idx_str,\n         ccw_block, ccw_val,\n         solid_block, solid_val,\n         convex_block, convex_val,\n         creaseAngle_block, creaseAngle_val) = match\n        \n        # 1. \u57fa\u7840\u4fe1\u606f\uff08FilamentSegment ID\uff09\n        seg_id = re.search(r'FilamentSegment\\d+', match[0]).group() if match[0] else 'Unknown_Segment'\n        \n        # 2. \u989c\u8272\u4fe1\u606f\n        if diffuseColor_block:\n            r, g, b = float(r), float(g), float(b)\n            rgb_255 = (int(r*255), int(g*255), int(b*255))\n            # \u7ed3\u6784\u7c7b\u578b\u5206\u7c7b\n            if r > 0.7 and g < 0.1 and b > 0.7:\n                color_desc = '\u6811\u7a81\uff08\u7d2b\u8272\uff09'\n            elif r > 0.9 and g < 0.1 and b < 0.1:\n                color_desc = '\u810a\u67f1\uff08\u7ea2\u8272\uff09'\n            else:\n                color_desc = '\u5176\u4ed6\u7ed3\u6784'\n        else:\n            rgb_255 = DEFAULT_COLOR\n            r, g, b = [c/255 for c in DEFAULT_COLOR]\n            color_desc = '\u65e0\u989c\u8272\u4fe1\u606f'\n        \n        # 3. \u9876\u70b9\u5750\u6807\uff08Coordinate \u2192 point\uff09\n        points_raw = re.findall(r'[-+]?\\d+\\.?\\d*e?[-+]?\\d*', point_str)\n        points = np.array(points_raw, dtype=np.float64).reshape(-1, 3) if points_raw else np.array([])\n        vertex_count = len(points)\n        \n        # 4. \u6cd5\u5411\u91cf\u4fe1\u606f\uff08Normal \u2192 vector\uff09\n        normal_vector = None\n        if normal_block:\n            normal_raw = re.findall(r'[-+]?\\d+\\.?\\d*', normal_vector_str)\n            normal_vector = tuple(map(float, normal_raw)) if len(normal_raw) == 3 else None\n        \n        # 5. \u9762\u7d22\u5f15\uff08coordIndex\uff09\n        coord_idx_groups = []\n        if coord_idx_str.strip():\n            idx_groups = re.split(r'-1\\s*', coord_idx_str.strip())\n            for group in idx_groups:\n                if group.strip():\n                    face_indices = [int(x) for x in group.split()]\n                    if len(set(face_indices)) >= 3:  # \u8fc7\u6ee4\u65e0\u6548\u9762\n                        coord_idx_groups.append(face_indices)\n        face_count = len(coord_idx_groups)\n        \n        # 6. \u5176\u4ed6IndexedFaceSet\u53c2\u6570\n        ccw = ccw_val.lower() if ccw_val else 'true'  # \u9ed8\u8ba4true\n        solid = solid_val.lower() if solid_val else 'false'  # \u9ed8\u8ba4false\n        convex = convex_val.lower() if convex_val else 'true'  # \u9ed8\u8ba4true\n        crease_angle = float(creaseAngle_val) if creaseAngle_val else 0.0\n        \n        # 7. normalIndex\uff08\u53ef\u9009\uff09\n        normal_idx_groups = []\n        if normalIndex_block and normal_idx_str.strip():\n            idx_groups = re.split(r'-1\\s*', normal_idx_str.strip())\n            for group in idx_groups:\n                if group.strip():\n                    normal_idx_groups.append([int(x) for x in group.split()])\n        \n        # \u6574\u7406\u6240\u6709\u7279\u5f81\n        parsed_data.append({\n            '\u57fa\u7840\u4fe1\u606f': {\n                'FilamentSegment ID': seg_id,\n                '\u7ed3\u6784\u7c7b\u578b': color_desc,\n                '\u9876\u70b9\u603b\u6570': vertex_count,\n                '\u6709\u6548\u9762\u603b\u6570': face_count\n            },\n            '\u989c\u8272\u4fe1\u606f': {\n                '\u539f\u59cbRGB(0-1)': (round(r, 6), round(g, 6), round(b, 6)),\n                '\u6807\u51c6\u5316RGB(0-255)': rgb_255,\n                '\u989c\u8272\u63cf\u8ff0': color_desc\n            },\n            'Coordinate\u8282\u70b9': {\n                'DEF ID': coord_def_id,\n                '\u9876\u70b9\u5750\u6807(point)': points.tolist(),  # \u8f6c\u4e3alist\u65b9\u4fbf\u5bfc\u51fa\n                '\u9876\u70b9\u603b\u6570': vertex_count\n            },\n            'Normal\u8282\u70b9': {\n                'DEF ID': normal_def_id if normal_def_id else '\u65e0',\n                '\u6cd5\u5411\u91cf(vector)': normal_vector,\n                '\u662f\u5426\u5b58\u5728\u6cd5\u5411\u91cf': bool(normal_block)\n            },\n            'IndexedFaceSet\u53c2\u6570': {\n                'coordIndex\uff08\u9762\u7d22\u5f15\u7ec4\uff09': coord_idx_groups,\n                'normalIndex\uff08\u6cd5\u5411\u91cf\u7d22\u5f15\u7ec4\uff09': normal_idx_groups if normal_idx_groups else '\u65e0',\n                'ccw\uff08\u9006\u65f6\u9488\u6392\u5e8f\uff09': ccw,\n                'solid\uff08\u662f\u5426\u4e3a\u5b9e\u5fc3\uff09': solid,\n                'convex\uff08\u662f\u5426\u51f8\u591a\u8fb9\u5f62\uff09': convex,\n                'creaseAngle\uff08\u6298\u75d5\u89d2\u5ea6\uff09': round(crease_angle, 6)\n            }\n        })\n    \n    return parsed_data\n\n# -------------------------- \u5de5\u5177\u51fd\u6570\uff1a\u622a\u65ad\u957f\u53c2\u6570\u663e\u793a --------------------------\ndef truncate_long_data(data, max_lines=3):\n    '''\u957f\u5217\u8868/\u6570\u7ec4\u663e\u793a\u65f6\u4ec5\u4fdd\u7559\u524dmax_lines\u884c\uff0c\u7ed3\u5c3e\u6807\u6ce8\u603b\u6570'''\n    if isinstance(data, list):\n        # \u5904\u7406\u9876\u70b9\u5750\u6807\uff08\u6bcf\u4e2a\u5143\u7d20\u662f[x,y,z]\uff09\n        if len(data) == 0:\n            return '\u65e0'\n        elif len(data) <= max_lines:\n            return [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data]\n        else:\n            truncated = [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data[:max_lines]]\n            truncated.append(f'...\uff08\u5171{len(data)}\u4e2a\u9876\u70b9\uff09')\n            return truncated\n    elif isinstance(data, list) and all(isinstance(item, list) for item in data):\n        # \u5904\u7406\u7d22\u5f15\u7ec4\uff08\u5982coordIndex_groups\uff09\n        if len(data) == 0:\n            return '\u65e0'\n        elif len(data) <= max_lines:\n            return [str(group) for group in data]\n        else:\n            truncated = [str(group) for group in data[:max_lines]]\n            truncated.append(f'...\uff08\u5171{len(data)}\u4e2a\u9762\u7d22\u5f15\u7ec4\uff09')\n            return truncated\n    else:\n        return data\n\n# -------------------------- \u6838\u5fc3\u529f\u80fd\uff1a\u5bfc\u51fa\u7b2c\u4e00\u4e2aFilamentSegment --------------------------\ndef export_first_segment_features(parsed_data):\n    if not parsed_data:\n        print('\u274c \u672a\u89e3\u6790\u5230\u4efb\u4f55FilamentSegment\u6570\u636e\uff01')\n        return\n    \n    # \u4ec5\u53d6\u7b2c\u4e00\u4e2aFilamentSegment\n    first_seg = parsed_data[0]\n    seg_id = first_seg['\u57fa\u7840\u4fe1\u606f']['FilamentSegment ID']\n    print(f'\ud83c\udf89 \u5f00\u59cb\u5bfc\u51fa\u7b2c\u4e00\u4e2aFilamentSegment\u7279\u5f81\uff1a{seg_id}\\n')\n\n    # -------------------------- 1. \u63a7\u5236\u53f0\u6253\u5370\uff08\u7b80\u5316\u957f\u53c2\u6570\uff09 --------------------------\n    print('='*60)\n    print('\ud83d\udccb \u7b2c\u4e00\u4e2aFilamentSegment\u5b8c\u6574\u7279\u5f81\uff08\u957f\u53c2\u6570\u4ec5\u663e\u793a\u524d3\u884c\uff09')\n    print('='*60)\n    \n    for category, features in first_seg.items():\n        print(f'\\n\u3010{category}\u3011')\n        for key, value in features.items():\n            # \u5bf9\u957f\u53c2\u6570\u8fdb\u884c\u622a\u65ad\u663e\u793a\n            if key in ['\u9876\u70b9\u5750\u6807(point)', 'coordIndex\uff08\u9762\u7d22\u5f15\u7ec4\uff09']:\n                truncated_val = truncate_long_data(value)\n                if isinstance(truncated_val, list):\n                    print(f'  {key}:')\n                    for line in truncated_val:\n                        print(f'    - {line}')\n                else:\n                    print(f'  {key}: {truncated_val}')\n            else:\n                print(f'  {key}: {value}')\n    \n    # -------------------------- 2. \u5bfc\u51fa\u5b8c\u6574\u6570\u636e\u5230\u6587\u4ef6 --------------------------\n    # \u751f\u6210\u5bfc\u51fa\u8def\u5f84\n    vrml_dir = os.path.dirname(VRML_FILE_PATH)\n    vrml_filename = Path(VRML_FILE_PATH).stem\n    export_filename = f'{vrml_filename}_\u7b2c\u4e00\u4e2aFilamentSegment_\u5b8c\u6574\u7279\u5f81.{EXPORT_FORMAT}'\n    export_path = os.path.join(vrml_dir, export_filename)\n    \n    # \u5bfc\u51fa\u4e3aJSON\uff08\u4fdd\u7559\u5b8c\u6574\u7ed3\u6784\uff09\u6216TXT\uff08\u6613\u8bfb\uff09\n    if EXPORT_FORMAT == 'json':\n        # \u8f6c\u6362numpy\u6570\u7ec4\u4e3alist\uff08JSON\u4e0d\u652f\u6301numpy\u7c7b\u578b\uff09\n        with open(export_path, 'w', encoding='utf-8') as f:\n            json.dump(first_seg, f, ensure_ascii=False, indent=2)\n    elif EXPORT_FORMAT == 'txt':\n        with open(export_path, 'w', encoding='utf-8') as f:\n            f.write(f'\u7b2c\u4e00\u4e2aFilamentSegment\u5b8c\u6574\u7279\u5f81 - {seg_id}\\n')\n            f.write('='*80 + '\\n\\n')\n            for category, features in first_seg.items():\n                f.write(f'\u3010{category}\u3011\\n')\n                for key, value in features.items():\n                    f.write(f'  {key}: {value}\\n')\n                f.write('\\n')\n    \n    print(f'\\n\ud83d\udcc1 \u5b8c\u6574\u7279\u5f81\u5df2\u5bfc\u51fa\u81f3\uff1a{export_path}')\n    print(f'\ud83d\udca1 \u5bfc\u51fa\u683c\u5f0f\uff1a{EXPORT_FORMAT}\uff08\u542b\u672a\u622a\u65ad\u7684\u5b8c\u6574\u6570\u636e\uff09')\n\n# -------------------------- \u4e3b\u51fd\u6570 --------------------------\nif __name__ == '__main__':\n    print('\ud83d\udce5 \u6b63\u5728\u89e3\u6790VRML\u6587\u4ef6...')\n    parsed_data = parse_vrml_manual(VRML_FILE_PATH)\n    \n    if parsed_data:\n        print(f'\u2705 \u5171\u89e3\u6790\u5230 {len(parsed_data)} \u4e2aFilamentSegment')\n        export_first_segment_features(parsed_data)\n    else:\n        print('\u274c \u89e3\u6790\u5931\u8d25\uff1a\u672a\u627e\u5230\u7b26\u5408\u8981\u6c42\u7684FilamentSegment\u7ed3\u6784\uff01')\n```\n\n\n# faces\n\n\n```\nimport vtk\nimport re\nimport numpy as np\n\n# -------------------------- \u914d\u7f6e\u53c2\u6570\uff08\u9002\u914d\u9762\u6e32\u67d3\uff0c\u4fdd\u7559\u6838\u5fc3\u9879\uff09 --------------------------\nVRML_FILE_PATH = r'C:\\Users\\liuj2\\Desktop\\10_PDGF x GFP-M#170_Control RH_01x.wrl'\nFACE_OPACITY = 0.7  # \u9762\u900f\u660e\u5ea6\uff080=\u900f\u660e\uff0c1=\u4e0d\u900f\u660e\uff09\nEDGE_WIDTH = 1.0    # \u9762\u8fb9\u7f18\u5bbd\u5ea6\uff08\u7a81\u51fa\u9762\u8fb9\u754c\uff09\nEDGE_COLOR = (0.0, 0.0, 0.0)  # \u9762\u8fb9\u7f18\u989c\u8272\uff08\u9ed1\u8272\uff09\nBACKGROUND_COLOR = (1.0, 1.0, 1.0)  # \u767d\u8272\u80cc\u666f\n\n# -------------------------- \u6838\u5fc3\u5de5\u5177\uff1a\u89e3\u6790coordIndex\u5e76\u4fdd\u7559-1\u4f5c\u4e3a\u9762\u5206\u9694\u7b26 --------------------------\ndef parse_vrml_manual(vrml_path):\n    '''\u624b\u52a8\u89e3\u6790VRML\uff0c\u4fdd\u7559coordIndex\u4e2d\u7684-1\uff0c\u63d0\u53d6\u9762\u6570\u636e\uff08ID\u3001\u989c\u8272\u3001\u9876\u70b9\u3001\u9762\u7d22\u5f15\u7ec4\uff09'''\n    with open(vrml_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    \n    # \u6b63\u5219\u5339\u914d\u6838\u5fc3\u6570\u636e\uff08FilamentSegment \u2192 \u989c\u8272 \u2192 \u9876\u70b9 \u2192 \u5e26-1\u7684coordIndex\uff09\n    pattern = r'''\n        DEF\\s+(FilamentSegment\\d+)\\s+Group\\s*\\{\\s*\n        .*?diffuseColor\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s+(\\d+\\.?\\d*)\\s*\n        .*?point\\s*\\[\\s*(.*?)\\s*\\]\n        .*?coordIndex\\s*\\[\\s*(.*?)\\s*\\]\n    '''\n    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)\n    \n    if not matches:\n        print('\u26a0\ufe0f  \u672a\u5339\u914d\u5230FilamentSegment\u6570\u636e\uff0c\u5c1d\u8bd5\u7b80\u5316\u5339\u914d\u89c4\u5219...')\n        pattern_simple = r'DEF\\s+(FilamentSegment\\d+)\\s+Group\\s*\\{\\s*.*?diffuseColor\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*.*?point\\s*\\[\\s*(.*?)\\s*\\]'\n        matches = re.findall(pattern_simple, content, re.DOTALL)\n    \n    parsed_data = []\n    for match in matches:\n        # \u89e3\u5305\u5339\u914d\u7ed3\u679c\uff08\u517c\u5bb9\u5b8c\u6574/\u7b80\u5316\u6b63\u5219\uff09\n        if len(match) == 6:\n            seg_id, r, g, b, point_str, coord_idx_str = match\n        else:\n            seg_id, r, g, b, point_str = match\n            coord_idx_str = ''\n        \n        # \u89e3\u6790\u989c\u8272\uff08\u8f6c\u4e3aVTK\u6240\u9700\u76840-255\u6574\u6570\uff09\n        r, g, b = float(r), float(g), float(b)\n        if r > 0.7 and g < 0.1 and b > 0.7:\n            rgb = (192, 0, 192)  # \u6811\u7a81\uff08\u7d2b\u8272\uff09\n        elif r > 0.9 and g < 0.1 and b < 0.1:\n            rgb = (255, 0, 0)    # \u810a\u67f1\uff08\u7ea2\u8272\uff09\n        else:\n            rgb = (128, 128, 128)  # \u5176\u4ed6\u7ed3\u6784\uff08\u7070\u8272\uff09\n        \n        # \u89e3\u6790\u9876\u70b9\u5750\u6807\uff08\u8f6c\u4e3a(n,3)\u6570\u7ec4\uff09\n        points = re.findall(r'[-+]?\\d+\\.?\\d*e?[-+]?\\d*', point_str)\n        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])\n        \n        # -------------------------- \u5173\u952e\u4fee\u6539\uff1a\u4fdd\u7559-1\uff0c\u6309-1\u5206\u5272\u9762\u7d22\u5f15 --------------------------\n        face_groups = []\n        if coord_idx_str.strip():\n            # \u6b65\u9aa41\uff1a\u79fb\u9664\u9017\u53f7\uff08\u5904\u7406'0,1,18,17,-1' \u2192 '0 1 18 17 -1'\uff09\n            coord_idx_str_clean = coord_idx_str.replace(',', '').strip()\n            # \u6b65\u9aa42\uff1a\u6309-1\u5206\u5272\uff0c\u5f97\u5230\u6bcf\u4e2a\u9762\u7684\u7d22\u5f15\u7ec4\uff08\u4fdd\u7559-1\u4f5c\u4e3a\u5206\u9694\u7b26\uff0c\u5206\u5272\u540e\u4e22\u5f03-1\uff09\n            idx_groups = re.split(r'-1\\s*', coord_idx_str_clean)\n            # \u6b65\u9aa43\uff1a\u8fc7\u6ee4\u7a7a\u7ec4\uff0c\u4e14\u6bcf\u4e2a\u9762\u9700\u22653\u4e2a\u9876\u70b9\u624d\u6709\u6548\n            for group in idx_groups:\n                if group.strip():\n                    face_indices = [int(x) for x in group.split()]\n                    if len(face_indices) >= 3:  # \u9762\u81f3\u5c11\u9700\u89813\u4e2a\u9876\u70b9\n                        face_groups.append(face_indices)\n        \n        # \u4ec5\u4fdd\u7559\u6709\u6548\u6570\u636e\uff08\u81f3\u5c113\u4e2a\u9876\u70b9 + \u81f3\u5c111\u4e2a\u6709\u6548\u9762\uff09\n        if len(points) >= 3 and len(face_groups) >= 1:\n            parsed_data.append({\n                'seg_id': seg_id,\n                'rgb': rgb,\n                'points': points,\n                'face_groups': face_groups  # \u5b58\u50a8\u6309-1\u5206\u5272\u540e\u7684\u9762\u7d22\u5f15\u7ec4\n            })\n    \n    return parsed_data\n\n# -------------------------- \u6838\u5fc3\u903b\u8f91\uff1aVTK\u7ed8\u5236\u9762\uff08face\uff09\u800c\u975e\u7ebf\uff08line\uff09 --------------------------\ndef vtk_face_visualization(parsed_data):\n    '''\u7528VTK\u7ed8\u52363D\u9762\uff0c\u4fdd\u7559\u9762\u8fb9\u7f18\uff0c\u65e0\u5197\u4f59\u529f\u80fd'''\n    vtk_poly_data = vtk.vtkPolyData()\n    vtk_points = vtk.vtkPoints()\n    vtk_faces = vtk.vtkCellArray()  # \u5b58\u50a8\u9762\uff08\u66ff\u6362\u539fvtkLines\uff09\n    color_map = vtk.vtkUnsignedCharArray()\n    color_map.SetNumberOfComponents(3)\n    color_map.SetName('Colors')\n\n    # \u904d\u5386\u89e3\u6790\u6570\u636e\uff0c\u6784\u5efaVTK\u9876\u70b9\u548c\u9762\n    for seg in parsed_data:\n        points = seg['points']\n        face_groups = seg['face_groups']  # \u6309-1\u5206\u5272\u540e\u7684\u9762\u7d22\u5f15\u7ec4\n        rgb = seg['rgb']\n\n        # \u6dfb\u52a0\u9876\u70b9\u548c\u989c\u8272\uff08\u4e0e\u539f\u903b\u8f91\u4e00\u81f4\uff09\n        start_point_id = vtk_points.GetNumberOfPoints()\n        for x, y, z in points:\n            vtk_points.InsertNextPoint(x, y, z)\n            color_map.InsertNextTuple3(*rgb)\n\n        # -------------------------- \u5173\u952e\u4fee\u6539\uff1a\u7528vtkPolygon\u521b\u5efa\u9762\uff08\u66ff\u6362\u539fvtkLine\uff09 --------------------------\n        for face_indices in face_groups:\n            # \u521b\u5efa\u5355\u4e2a\u9762\uff08\u591a\u8fb9\u5f62\uff09\n            polygon = vtk.vtkPolygon()\n            polygon.GetPointIds().SetNumberOfIds(len(face_indices))\n            # \u6620\u5c04\u5c40\u90e8\u7d22\u5f15\u5230\u5168\u5c40\u9876\u70b9ID\n            for i, idx in enumerate(face_indices):\n                global_point_id = start_point_id + idx\n                polygon.GetPointIds().SetId(i, global_point_id)\n            # \u6dfb\u52a0\u9762\u5230\u9762\u6570\u7ec4\n            vtk_faces.InsertNextCell(polygon)\n\n    # \u7ec4\u88c5VTK\u6570\u636e\uff08\u7528SetPolys\u66ff\u6362\u539fSetLines\uff09\n    vtk_poly_data.SetPoints(vtk_points)\n    vtk_poly_data.SetPolys(vtk_faces)  # \u7ed8\u5236\u9762\uff08\u6838\u5fc3\u4fee\u6539\uff09\n    vtk_poly_data.GetPointData().SetScalars(color_map)\n\n    # \u914d\u7f6eVTK\u6e32\u67d3\u7ba1\u7ebf\uff08\u9002\u914d\u9762\u6e32\u67d3\uff09\n    mapper = vtk.vtkPolyDataMapper()\n    mapper.SetInputData(vtk_poly_data)\n    mapper.ScalarVisibilityOn()\n\n    actor = vtk.vtkActor()\n    actor.SetMapper(mapper)\n    # \u9762\u6e32\u67d3\u5c5e\u6027\uff08\u900f\u660e\u5ea6+\u8fb9\u7f18\uff09\n    actor.GetProperty().SetOpacity(FACE_OPACITY)\n    actor.GetProperty().SetEdgeVisibility(True)  # \u663e\u793a\u9762\u8fb9\u7f18\n    actor.GetProperty().SetEdgeColor(*EDGE_COLOR)  # \u8fb9\u7f18\u989c\u8272\n    actor.GetProperty().SetLineWidth(EDGE_WIDTH)  # \u8fb9\u7f18\u5bbd\u5ea6\n\n    # \u6e32\u67d3\u5668\u914d\u7f6e\uff08\u4e0e\u539f\u903b\u8f91\u4e00\u81f4\uff09\n    renderer = vtk.vtkRenderer()\n    renderer.AddActor(actor)\n    renderer.SetBackground(*BACKGROUND_COLOR)\n    renderer.ResetCamera()  # \u81ea\u52a8\u9002\u914d\u6240\u6709\u9762\n\n    render_window = vtk.vtkRenderWindow()\n    render_window.SetWindowName('\u795e\u7ecf\u7ec6\u4e1dVTK\u9762\u53ef\u89c6\u5316')\n    render_window.SetSize(1200, 900)\n    render_window.AddRenderer(renderer)\n\n    interactor = vtk.vtkRenderWindowInteractor()\n    interactor.SetRenderWindow(render_window)\n\n    # \u542f\u52a8\u53ef\u89c6\u5316\u4ea4\u4e92\uff08\u4e0e\u539f\u903b\u8f91\u4e00\u81f4\uff09\n    interactor.Initialize()\n    render_window.Render()\n    print('\ud83d\uddb1\ufe0f  \u4ea4\u4e92\u6307\u5357\uff1a')\n    print('   - \u5de6\u952e\u62d6\u62fd\uff1a\u65cb\u8f6c\u573a\u666f')\n    print('   - \u6eda\u8f6e\uff1a\u7f29\u653e\u753b\u9762')\n    print('   - \u53f3\u952e\u62d6\u62fd\uff1a\u5e73\u79fb\u573a\u666f')\n    print('   - \u6309 'q' \u952e\u5173\u95ed\u7a97\u53e3')\n    interactor.Start()\n\n# -------------------------- \u4e3b\u51fd\u6570\uff08\u7eaf\u9762\u53ef\u89c6\u5316\u6d41\u7a0b\uff09 --------------------------\nif __name__ == '__main__':\n    # 1. \u89e3\u6790VRML\uff08\u4fdd\u7559-1\uff0c\u63d0\u53d6\u9762\u6570\u636e\uff09\n    print('\ud83d\udce5 \u6b63\u5728\u89e3\u6790VRML\u6587\u4ef6...')\n    parsed_data = parse_vrml_manual(VRML_FILE_PATH)\n\n    if not parsed_data:\n        print('\u274c \u672a\u63d0\u53d6\u5230\u6709\u6548\u9762\u6570\u636e\uff01')\n    else:\n        total_segments = len(parsed_data)\n        total_faces = sum(len(seg['face_groups']) for seg in parsed_data)\n        total_points = sum(len(seg['points']) for seg in parsed_data)\n        print(f'\u2705 \u6210\u529f\u89e3\u6790 {total_segments} \u4e2a\u795e\u7ecf\u7ec6\u4e1d\u6bb5\uff0c{total_points} \u4e2a\u9876\u70b9\uff0c{total_faces} \u4e2a\u9762\uff0c\u542f\u52a8VTK\u9762\u53ef\u89c6\u5316...')\n        # 2. VTK\u7ed8\u5236\u9762\uff08\u65e0\u5176\u4ed6\u529f\u80fd\uff09\n        vtk_face_visualization(parsed_data)\n```\u3002", "top": 0, "createdAt": 1764165811, "style": "", "script": "", "head": "", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "createdDate": "2025-11-26", "dateLabelColor": "#0969da"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "wontfix": "#ffffff"}, "displayTitle": "Blog Title", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "ogImage": "https://github.githubassets.com/favicons/favicon.svg", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://conanan.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}