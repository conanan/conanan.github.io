<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# point
```
import vtk
import re
import numpy as np

# -------------------------- é…ç½®å‚æ•°ï¼ˆæ–°å¢ç‚¹å¤§å°è®¾ç½®ï¼‰ --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
POINT_SIZE = 5.0  # é¡¶ç‚¹å¤§å°ï¼ˆå¯è°ƒæ•´ï¼Œè¶Šå¤§è¶Šæ¸…æ™°ï¼‰
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯

# -------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æé€»è¾‘ä¸å˜ï¼ˆä»æå–é¡¶ç‚¹æ•°æ®ï¼‰ --------------------------
def parse_vrml_manual(vrml_path):
    '''æ‰‹åŠ¨è§£æVRMLï¼Œæå–é¡¶ç‚¹ã€é¢œè‰²ç­‰æ•°æ®ï¼ˆè§£æé€»è¾‘ä¸å˜ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ ç´¢å¼•ï¼‰
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
        .*?point\s*\[\s*(.*?)\s*\]
        .*?coordIndex\s*\[\s*(.*?)\s*\]
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)
    
    if not matches:
        print('âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...')
        pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
        matches = re.findall(pattern_simple, content, re.DOTALL)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
        if len(match) == 6:
            seg_id, r, g, b, point_str, coord_idx_str = match
        else:
            seg_id, r, g, b, point_str = match
            coord_idx_str = ''
        
        # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
        r, g, b = float(r), float(g), float(b)
        if r > 0.7 and g < 0.1 and b > 0.7:
            rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
        elif r > 0.9 and g < 0.1 and b < 0.1:
            rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
        else:
            rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
        
        # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
        points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
        
        # ä»…ä¿ç•™æœ‰é¡¶ç‚¹çš„æ•°æ®ï¼ˆè‡³å°‘1ä¸ªé¡¶ç‚¹å³å¯ï¼‰
        if len(points) >= 1:
            parsed_data.append({
                'seg_id': seg_id,
                'rgb': rgb,
                'points': points
            })
    
    return parsed_data

# -------------------------- æ ¸å¿ƒé€»è¾‘ï¼šä»…æ¸²æŸ“é¡¶ç‚¹ï¼ˆä¸è¿æ¥çº¿æ®µï¼‰ --------------------------
def vtk_render_points_only(parsed_data):
    '''çº¯é¡¶ç‚¹æ¸²æŸ“ï¼Œä¸æ„å»ºä»»ä½•çº¿æ®µ'''
    vtk_poly_data = vtk.vtkPolyData()
    vtk_points = vtk.vtkPoints()
    vtk_vertices = vtk.vtkCellArray()  # ç”¨äºå­˜å‚¨é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„vtkLinesï¼‰
    color_map = vtk.vtkUnsignedCharArray()
    color_map.SetNumberOfComponents(3)
    color_map.SetName('Colors')

    # éå†è§£ææ•°æ®ï¼Œæ·»åŠ æ‰€æœ‰é¡¶ç‚¹ï¼ˆä¸å¤„ç†è¿æ¥å…³ç³»ï¼‰
    for seg in parsed_data:
        points = seg['points']
        rgb = seg['rgb']

        # é€ä¸ªæ·»åŠ é¡¶ç‚¹å’Œå¯¹åº”çš„é¢œè‰²
        for x, y, z in points:
            # æ·»åŠ é¡¶ç‚¹åæ ‡
            point_id = vtk_points.InsertNextPoint(x, y, z)
            # æ·»åŠ é¡¶ç‚¹é¢œè‰²
            color_map.InsertNextTuple3(*rgb)
            # åˆ›å»ºå•ä¸ªé¡¶ç‚¹å•å…ƒï¼ˆå…³é”®ï¼šæ¯ä¸ªç‚¹ä½œä¸ºç‹¬ç«‹å•å…ƒï¼‰
            vertex = vtk.vtkVertex()
            vertex.GetPointIds().SetId(0, point_id)
            vtk_vertices.InsertNextCell(vertex)

    # ç»„è£…VTKæ•°æ®ï¼ˆç”¨é¡¶ç‚¹å•å…ƒæ›¿æ¢çº¿æ®µå•å…ƒï¼‰
    vtk_poly_data.SetPoints(vtk_points)
    vtk_poly_data.SetVerts(vtk_vertices)  # æ¸²æŸ“é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„SetLinesï¼‰
    vtk_poly_data.GetPointData().SetScalars(color_map)

    # é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé‡ç‚¹è®¾ç½®ç‚¹å¤§å°ï¼‰
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(vtk_poly_data)
    mapper.ScalarVisibilityOn()  # å¯ç”¨é¢œè‰²æ˜ å°„

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetPointSize(POINT_SIZE)  # è®¾ç½®é¡¶ç‚¹å¤§å°ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰

    # æ¸²æŸ“å™¨é…ç½®
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(*BACKGROUND_COLOR)
    renderer.ResetCamera()  # è‡ªåŠ¨è°ƒæ•´è§†è§’ä»¥åŒ…å«æ‰€æœ‰ç‚¹

    # çª—å£é…ç½®
    render_window = vtk.vtkRenderWindow()
    render_window.SetWindowName('ç¥ç»ç»†ä¸é¡¶ç‚¹å¯è§†åŒ–ï¼ˆä»…æ˜¾ç¤ºç‚¹ï¼‰')
    render_window.SetSize(1200, 900)
    render_window.AddRenderer(renderer)

    # äº¤äº’å™¨é…ç½®
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    # å¯åŠ¨å¯è§†åŒ–
    interactor.Initialize()
    render_window.Render()
    print('ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š')
    print('   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯')
    print('   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢')
    print('   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯')
    print('   - æŒ‰ 'q' é”®å…³é—­çª—å£')
    interactor.Start()

# -------------------------- ä¸»æ‰§è¡Œæµç¨‹ --------------------------
# 1. è§£æVRMLï¼ˆæå–é¡¶ç‚¹æ•°æ®ï¼‰
print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
parsed_data = parse_vrml_manual(VRML_FILE_PATH)

if not parsed_data:
    print('âŒ æœªæå–åˆ°æœ‰æ•ˆé¡¶ç‚¹æ•°æ®ï¼')
else:
    # ç»Ÿè®¡æ€»é¡¶ç‚¹æ•°
    total_points = sum(len(seg['points']) for seg in parsed_data)
    print(f'âœ… æˆåŠŸè§£æ {len(parsed_data)} ä¸ªçº¿æ®µï¼Œå…± {total_points} ä¸ªé¡¶ç‚¹ï¼Œå¯åŠ¨é¡¶ç‚¹å¯è§†åŒ–...')
    # 2. ä»…æ¸²æŸ“é¡¶ç‚¹
    vtk_render_points_only(parsed_data)
```



# lines

`import re
import numpy as np
import json
from pathlib import Path
import os

# -------------------------- é…ç½®å‚æ•° --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
EXPORT_FORMAT = 'json'  # å¯¼å‡ºæ ¼å¼ï¼š'json'ï¼ˆæ¨èï¼Œä¿ç•™ç»“æ„ï¼‰æˆ– 'txt'ï¼ˆæ˜“è¯»ï¼‰
DEFAULT_COLOR = (128, 128, 128)  # æ— diffuseColoræ—¶çš„é»˜è®¤é¢œè‰²

# -------------------------- æ ¸å¿ƒè§£æå‡½æ•°ï¼ˆä¿ç•™æ‰€æœ‰ç‰¹å¾ï¼‰ --------------------------
def parse_vrml_manual(vrml_path):
    '''è§£æVRMLï¼Œæå–æ‰€æœ‰FilamentSegmentçš„å®Œæ•´ç‰¹å¾ï¼ˆé€‚é…IndexedFaceSetç»“æ„ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # ç²¾å‡†åŒ¹é…ï¼šFilamentSegment â†’ diffuseColor â†’ IndexedFaceSet â†’ Coordinate(point) + coordIndex
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?
        (diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*)?  # é¢œè‰²ï¼ˆå¯é€‰ï¼‰
        .*?
        IndexedFaceSet\s*\{\s*
        .*?
        (coord\s+DEF\s+(\w+)\s+Coordinate\s*\{\s*point\s*\[\s*(.*?)\s*\]\s*\}\s*)  # CoordinateèŠ‚ç‚¹ï¼ˆå«pointï¼‰
        .*?
        (normal\s+DEF\s+(\w+)\s+Normal\s*\{\s*vector\s*(.*?)\s*\}\s*)?  # NormalèŠ‚ç‚¹ï¼ˆå¯é€‰ï¼Œå«æ³•å‘é‡ï¼‰
        .*?
        (coordIndex\s*\[\s*(.*?)\s*\])  # coordIndexï¼ˆé¢ç´¢å¼•ï¼‰
        .*?
        (normalIndex\s*\[\s*(.*?)\s*\])?  # normalIndexï¼ˆå¯é€‰ï¼‰
        .*?
        (ccw\s+(\w+))?\s*  # ccwå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (solid\s+(\w+))?\s*  # solidå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (convex\s+(\w+))?\s*  # convexå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (creaseAngle\s+(\d+\.?\d*))?\s*  # creaseAngleå‚æ•°ï¼ˆå¯é€‰ï¼‰
        .*?\}\s*  # å…³é—­IndexedFaceSet
        .*?\}\s*  # å…³é—­FilamentSegment Group
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE | re.IGNORECASE)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆæŒ‰æ­£åˆ™åˆ†ç»„é¡ºåºï¼‰
        (diffuseColor_block, r, g, b,
         coord_block, coord_def_id, point_str,
         normal_block, normal_def_id, normal_vector_str,
         coordIndex_block, coord_idx_str,
         normalIndex_block, normal_idx_str,
         ccw_block, ccw_val,
         solid_block, solid_val,
         convex_block, convex_val,
         creaseAngle_block, creaseAngle_val) = match
        
        # 1. åŸºç¡€ä¿¡æ¯ï¼ˆFilamentSegment IDï¼‰
        seg_id = re.search(r'FilamentSegment\d+', match[0]).group() if match[0] else 'Unknown_Segment'
        
        # 2. é¢œè‰²ä¿¡æ¯
        if diffuseColor_block:
            r, g, b = float(r), float(g), float(b)
            rgb_255 = (int(r*255), int(g*255), int(b*255))
            # ç»“æ„ç±»å‹åˆ†ç±»
            if r > 0.7 and g < 0.1 and b > 0.7:
                color_desc = 'æ ‘çªï¼ˆç´«è‰²ï¼‰'
            elif r > 0.9 and g < 0.1 and b < 0.1:
                color_desc = 'è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰'
            else:
                color_desc = 'å…¶ä»–ç»“æ„'
        else:
            rgb_255 = DEFAULT_COLOR
            r, g, b = [c/255 for c in DEFAULT_COLOR]
            color_desc = 'æ— é¢œè‰²ä¿¡æ¯'
        
        # 3. é¡¶ç‚¹åæ ‡ï¼ˆCoordinate â†’ pointï¼‰
        points_raw = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points_raw, dtype=np.float64).reshape(-1, 3) if points_raw else np.array([])
        vertex_count = len(points)
        
        # 4. æ³•å‘é‡ä¿¡æ¯ï¼ˆNormal â†’ vectorï¼‰
        normal_vector = None
        if normal_block:
            normal_raw = re.findall(r'[-+]?\d+\.?\d*', normal_vector_str)
            normal_vector = tuple(map(float, normal_raw)) if len(normal_raw) == 3 else None
        
        # 5. é¢ç´¢å¼•ï¼ˆcoordIndexï¼‰
        coord_idx_groups = []
        if coord_idx_str.strip():
            idx_groups = re.split(r'-1\s*', coord_idx_str.strip())
            for group in idx_groups:
                if group.strip():
                    face_indices = [int(x) for x in group.split()]
                    if len(set(face_indices)) >= 3:  # è¿‡æ»¤æ— æ•ˆé¢
                        coord_idx_groups.append(face_indices)
        face_count = len(coord_idx_groups)
        
        # 6. å…¶ä»–IndexedFaceSetå‚æ•°
        ccw = ccw_val.lower() if ccw_val else 'true'  # é»˜è®¤true
        solid = solid_val.lower() if solid_val else 'false'  # é»˜è®¤false
        convex = convex_val.lower() if convex_val else 'true'  # é»˜è®¤true
        crease_angle = float(creaseAngle_val) if creaseAngle_val else 0.0
        
        # 7. normalIndexï¼ˆå¯é€‰ï¼‰
        normal_idx_groups = []
        if normalIndex_block and normal_idx_str.strip():
            idx_groups = re.split(r'-1\s*', normal_idx_str.strip())
            for group in idx_groups:
                if group.strip():
                    normal_idx_groups.append([int(x) for x in group.split()])
        
        # æ•´ç†æ‰€æœ‰ç‰¹å¾
        parsed_data.append({
            'åŸºç¡€ä¿¡æ¯': {
                'FilamentSegment ID': seg_id,
                'ç»“æ„ç±»å‹': color_desc,
                'é¡¶ç‚¹æ€»æ•°': vertex_count,
                'æœ‰æ•ˆé¢æ€»æ•°': face_count
            },
            'é¢œè‰²ä¿¡æ¯': {
                'åŸå§‹RGB(0-1)': (round(r, 6), round(g, 6), round(b, 6)),
                'æ ‡å‡†åŒ–RGB(0-255)': rgb_255,
                'é¢œè‰²æè¿°': color_desc
            },
            'CoordinateèŠ‚ç‚¹': {
                'DEF ID': coord_def_id,
                'é¡¶ç‚¹åæ ‡(point)': points.tolist(),  # è½¬ä¸ºlistæ–¹ä¾¿å¯¼å‡º
                'é¡¶ç‚¹æ€»æ•°': vertex_count
            },
            'NormalèŠ‚ç‚¹': {
                'DEF ID': normal_def_id if normal_def_id else 'æ— ',
                'æ³•å‘é‡(vector)': normal_vector,
                'æ˜¯å¦å­˜åœ¨æ³•å‘é‡': bool(normal_block)
            },
            'IndexedFaceSetå‚æ•°': {
                'coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰': coord_idx_groups,
                'normalIndexï¼ˆæ³•å‘é‡ç´¢å¼•ç»„ï¼‰': normal_idx_groups if normal_idx_groups else 'æ— ',
                'ccwï¼ˆé€†æ—¶é’ˆæ’åºï¼‰': ccw,
                'solidï¼ˆæ˜¯å¦ä¸ºå®å¿ƒï¼‰': solid,
                'convexï¼ˆæ˜¯å¦å‡¸å¤šè¾¹å½¢ï¼‰': convex,
                'creaseAngleï¼ˆæŠ˜ç—•è§’åº¦ï¼‰': round(crease_angle, 6)
            }
        })
    
    return parsed_data

# -------------------------- å·¥å…·å‡½æ•°ï¼šæˆªæ–­é•¿å‚æ•°æ˜¾ç¤º --------------------------
def truncate_long_data(data, max_lines=3):
    '''é•¿åˆ—è¡¨/æ•°ç»„æ˜¾ç¤ºæ—¶ä»…ä¿ç•™å‰max_linesè¡Œï¼Œç»“å°¾æ ‡æ³¨æ€»æ•°'''
    if isinstance(data, list):
        # å¤„ç†é¡¶ç‚¹åæ ‡ï¼ˆæ¯ä¸ªå…ƒç´ æ˜¯[x,y,z]ï¼‰
        if len(data) == 0:
            return 'æ— '
        elif len(data) <= max_lines:
            return [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data]
        else:
            truncated = [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data[:max_lines]]
            truncated.append(f'...ï¼ˆå…±{len(data)}ä¸ªé¡¶ç‚¹ï¼‰')
            return truncated
    elif isinstance(data, list) and all(isinstance(item, list) for item in data):
        # å¤„ç†ç´¢å¼•ç»„ï¼ˆå¦‚coordIndex_groupsï¼‰
        if len(data) == 0:
            return 'æ— '
        elif len(data) <= max_lines:
            return [str(group) for group in data]
        else:
            truncated = [str(group) for group in data[:max_lines]]
            truncated.append(f'...ï¼ˆå…±{len(data)}ä¸ªé¢ç´¢å¼•ç»„ï¼‰')
            return truncated
    else:
        return data

# -------------------------- æ ¸å¿ƒåŠŸèƒ½ï¼šå¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegment --------------------------
def export_first_segment_features(parsed_data):
    if not parsed_data:
        print('âŒ æœªè§£æåˆ°ä»»ä½•FilamentSegmentæ•°æ®ï¼')
        return
    
    # ä»…å–ç¬¬ä¸€ä¸ªFilamentSegment
    first_seg = parsed_data[0]
    seg_id = first_seg['åŸºç¡€ä¿¡æ¯']['FilamentSegment ID']
    print(f'ğŸ‰ å¼€å§‹å¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegmentç‰¹å¾ï¼š{seg_id}\n')

    # -------------------------- 1. æ§åˆ¶å°æ‰“å°ï¼ˆç®€åŒ–é•¿å‚æ•°ï¼‰ --------------------------
    print('='*60)
    print('ğŸ“‹ ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ï¼ˆé•¿å‚æ•°ä»…æ˜¾ç¤ºå‰3è¡Œï¼‰')
    print('='*60)
    
    for category, features in first_seg.items():
        print(f'\nã€{category}ã€‘')
        for key, value in features.items():
            # å¯¹é•¿å‚æ•°è¿›è¡Œæˆªæ–­æ˜¾ç¤º
            if key in ['é¡¶ç‚¹åæ ‡(point)', 'coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰']:
                truncated_val = truncate_long_data(value)
                if isinstance(truncated_val, list):
                    print(f'  {key}:')
                    for line in truncated_val:
                        print(f'    - {line}')
                else:
                    print(f'  {key}: {truncated_val}')
            else:
                print(f'  {key}: {value}')
    
    # -------------------------- 2. å¯¼å‡ºå®Œæ•´æ•°æ®åˆ°æ–‡ä»¶ --------------------------
    # ç”Ÿæˆå¯¼å‡ºè·¯å¾„
    vrml_dir = os.path.dirname(VRML_FILE_PATH)
    vrml_filename = Path(VRML_FILE_PATH).stem
    export_filename = f'{vrml_filename}_ç¬¬ä¸€ä¸ªFilamentSegment_å®Œæ•´ç‰¹å¾.{EXPORT_FORMAT}'
    export_path = os.path.join(vrml_dir, export_filename)
    
    # å¯¼å‡ºä¸ºJSONï¼ˆä¿ç•™å®Œæ•´ç»“æ„ï¼‰æˆ–TXTï¼ˆæ˜“è¯»ï¼‰
    if EXPORT_FORMAT == 'json':
        # è½¬æ¢numpyæ•°ç»„ä¸ºlistï¼ˆJSONä¸æ”¯æŒnumpyç±»å‹ï¼‰
        with open(export_path, 'w', encoding='utf-8') as f:
            json.dump(first_seg, f, ensure_ascii=False, indent=2)
    elif EXPORT_FORMAT == 'txt':
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(f'ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ - {seg_id}\n')
            f.write('='*80 + '\n\n')
            for category, features in first_seg.items():
                f.write(f'ã€{category}ã€‘\n')
                for key, value in features.items():
                    f.write(f'  {key}: {value}\n')
                f.write('\n')
    
    print(f'\nğŸ“ å®Œæ•´ç‰¹å¾å·²å¯¼å‡ºè‡³ï¼š{export_path}')
    print(f'ğŸ’¡ å¯¼å‡ºæ ¼å¼ï¼š{EXPORT_FORMAT}ï¼ˆå«æœªæˆªæ–­çš„å®Œæ•´æ•°æ®ï¼‰')

# -------------------------- ä¸»å‡½æ•° --------------------------
if __name__ == '__main__':
    print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
    parsed_data = parse_vrml_manual(VRML_FILE_PATH)
    
    if parsed_data:
        print(f'âœ… å…±è§£æåˆ° {len(parsed_data)} ä¸ªFilamentSegment')
        export_first_segment_features(parsed_data)
    else:
        print('âŒ è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„FilamentSegmentç»“æ„ï¼')`
# faces
`import vtk
import re
import numpy as np

# -------------------------- é…ç½®å‚æ•°ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼Œä¿ç•™æ ¸å¿ƒé¡¹ï¼‰ --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
FACE_OPACITY = 0.7  # é¢é€æ˜åº¦ï¼ˆ0=é€æ˜ï¼Œ1=ä¸é€æ˜ï¼‰
EDGE_WIDTH = 1.0    # é¢è¾¹ç¼˜å®½åº¦ï¼ˆçªå‡ºé¢è¾¹ç•Œï¼‰
EDGE_COLOR = (0.0, 0.0, 0.0)  # é¢è¾¹ç¼˜é¢œè‰²ï¼ˆé»‘è‰²ï¼‰
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯

# -------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æcoordIndexå¹¶ä¿ç•™-1ä½œä¸ºé¢åˆ†éš”ç¬¦ --------------------------
def parse_vrml_manual(vrml_path):
    '''æ‰‹åŠ¨è§£æVRMLï¼Œä¿ç•™coordIndexä¸­çš„-1ï¼Œæå–é¢æ•°æ®ï¼ˆIDã€é¢œè‰²ã€é¡¶ç‚¹ã€é¢ç´¢å¼•ç»„ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ å¸¦-1çš„coordIndexï¼‰
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
        .*?point\s*\[\s*(.*?)\s*\]
        .*?coordIndex\s*\[\s*(.*?)\s*\]
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)
    
    if not matches:
        print('âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...')
        pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
        matches = re.findall(pattern_simple, content, re.DOTALL)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
        if len(match) == 6:
            seg_id, r, g, b, point_str, coord_idx_str = match
        else:
            seg_id, r, g, b, point_str = match
            coord_idx_str = ''
        
        # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
        r, g, b = float(r), float(g), float(b)
        if r > 0.7 and g < 0.1 and b > 0.7:
            rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
        elif r > 0.9 and g < 0.1 and b < 0.1:
            rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
        else:
            rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
        
        # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
        points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
        
        # -------------------------- å…³é”®ä¿®æ”¹ï¼šä¿ç•™-1ï¼ŒæŒ‰-1åˆ†å‰²é¢ç´¢å¼• --------------------------
        face_groups = []
        if coord_idx_str.strip():
            # æ­¥éª¤1ï¼šç§»é™¤é€—å·ï¼ˆå¤„ç†'0,1,18,17,-1' â†’ '0 1 18 17 -1'ï¼‰
            coord_idx_str_clean = coord_idx_str.replace(',', '').strip()
            # æ­¥éª¤2ï¼šæŒ‰-1åˆ†å‰²ï¼Œå¾—åˆ°æ¯ä¸ªé¢çš„ç´¢å¼•ç»„ï¼ˆä¿ç•™-1ä½œä¸ºåˆ†éš”ç¬¦ï¼Œåˆ†å‰²åä¸¢å¼ƒ-1ï¼‰
            idx_groups = re.split(r'-1\s*', coord_idx_str_clean)
            # æ­¥éª¤3ï¼šè¿‡æ»¤ç©ºç»„ï¼Œä¸”æ¯ä¸ªé¢éœ€â‰¥3ä¸ªé¡¶ç‚¹æ‰æœ‰æ•ˆ
            for group in idx_groups:
                if group.strip():
                    face_indices = [int(x) for x in group.split()]
                    if len(face_indices) >= 3:  # é¢è‡³å°‘éœ€è¦3ä¸ªé¡¶ç‚¹
                        face_groups.append(face_indices)
        
        # ä»…ä¿ç•™æœ‰æ•ˆæ•°æ®ï¼ˆè‡³å°‘3ä¸ªé¡¶ç‚¹ + è‡³å°‘1ä¸ªæœ‰æ•ˆé¢ï¼‰
        if len(points) >= 3 and len(face_groups) >= 1:
            parsed_data.append({
                'seg_id': seg_id,
                'rgb': rgb,
                'points': points,
                'face_groups': face_groups  # å­˜å‚¨æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
            })
    
    return parsed_data

# -------------------------- æ ¸å¿ƒé€»è¾‘ï¼šVTKç»˜åˆ¶é¢ï¼ˆfaceï¼‰è€Œéçº¿ï¼ˆlineï¼‰ --------------------------
def vtk_face_visualization(parsed_data):
    '''ç”¨VTKç»˜åˆ¶3Dé¢ï¼Œä¿ç•™é¢è¾¹ç¼˜ï¼Œæ— å†—ä½™åŠŸèƒ½'''
    vtk_poly_data = vtk.vtkPolyData()
    vtk_points = vtk.vtkPoints()
    vtk_faces = vtk.vtkCellArray()  # å­˜å‚¨é¢ï¼ˆæ›¿æ¢åŸvtkLinesï¼‰
    color_map = vtk.vtkUnsignedCharArray()
    color_map.SetNumberOfComponents(3)
    color_map.SetName('Colors')

    # éå†è§£ææ•°æ®ï¼Œæ„å»ºVTKé¡¶ç‚¹å’Œé¢
    for seg in parsed_data:
        points = seg['points']
        face_groups = seg['face_groups']  # æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
        rgb = seg['rgb']

        # æ·»åŠ é¡¶ç‚¹å’Œé¢œè‰²ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
        start_point_id = vtk_points.GetNumberOfPoints()
        for x, y, z in points:
            vtk_points.InsertNextPoint(x, y, z)
            color_map.InsertNextTuple3(*rgb)

        # -------------------------- å…³é”®ä¿®æ”¹ï¼šç”¨vtkPolygonåˆ›å»ºé¢ï¼ˆæ›¿æ¢åŸvtkLineï¼‰ --------------------------
        for face_indices in face_groups:
            # åˆ›å»ºå•ä¸ªé¢ï¼ˆå¤šè¾¹å½¢ï¼‰
            polygon = vtk.vtkPolygon()
            polygon.GetPointIds().SetNumberOfIds(len(face_indices))
            # æ˜ å°„å±€éƒ¨ç´¢å¼•åˆ°å…¨å±€é¡¶ç‚¹ID
            for i, idx in enumerate(face_indices):
                global_point_id = start_point_id + idx
                polygon.GetPointIds().SetId(i, global_point_id)
            # æ·»åŠ é¢åˆ°é¢æ•°ç»„
            vtk_faces.InsertNextCell(polygon)

    # ç»„è£…VTKæ•°æ®ï¼ˆç”¨SetPolysæ›¿æ¢åŸSetLinesï¼‰
    vtk_poly_data.SetPoints(vtk_points)
    vtk_poly_data.SetPolys(vtk_faces)  # ç»˜åˆ¶é¢ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰
    vtk_poly_data.GetPointData().SetScalars(color_map)

    # é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼‰
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(vtk_poly_data)
    mapper.ScalarVisibilityOn()

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    # é¢æ¸²æŸ“å±æ€§ï¼ˆé€æ˜åº¦+è¾¹ç¼˜ï¼‰
    actor.GetProperty().SetOpacity(FACE_OPACITY)
    actor.GetProperty().SetEdgeVisibility(True)  # æ˜¾ç¤ºé¢è¾¹ç¼˜
    actor.GetProperty().SetEdgeColor(*EDGE_COLOR)  # è¾¹ç¼˜é¢œè‰²
    actor.GetProperty().SetLineWidth(EDGE_WIDTH)  # è¾¹ç¼˜å®½åº¦

    # æ¸²æŸ“å™¨é…ç½®ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(*BACKGROUND_COLOR)
    renderer.ResetCamera()  # è‡ªåŠ¨é€‚é…æ‰€æœ‰é¢

    render_window = vtk.vtkRenderWindow()
    render_window.SetWindowName('ç¥ç»ç»†ä¸VTKé¢å¯è§†åŒ–')
    render_window.SetSize(1200, 900)
    render_window.AddRenderer(renderer)

    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    # å¯åŠ¨å¯è§†åŒ–äº¤äº’ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
    interactor.Initialize()
    render_window.Render()
    print('ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š')
    print('   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯')
    print('   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢')
    print('   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯')
    print('   - æŒ‰ 'q' é”®å…³é—­çª—å£')
    interactor.Start()

# -------------------------- ä¸»å‡½æ•°ï¼ˆçº¯é¢å¯è§†åŒ–æµç¨‹ï¼‰ --------------------------
if __name__ == '__main__':
    # 1. è§£æVRMLï¼ˆä¿ç•™-1ï¼Œæå–é¢æ•°æ®ï¼‰
    print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
    parsed_data = parse_vrml_manual(VRML_FILE_PATH)

    if not parsed_data:
        print('âŒ æœªæå–åˆ°æœ‰æ•ˆé¢æ•°æ®ï¼')
    else:
        total_segments = len(parsed_data)
        total_faces = sum(len(seg['face_groups']) for seg in parsed_data)
        total_points = sum(len(seg['points']) for seg in parsed_data)
        print(f'âœ… æˆåŠŸè§£æ {total_segments} ä¸ªç¥ç»ç»†ä¸æ®µï¼Œ{total_points} ä¸ªé¡¶ç‚¹ï¼Œ{total_faces} ä¸ªé¢ï¼Œå¯åŠ¨VTKé¢å¯è§†åŒ–...')
        # 2. VTKç»˜åˆ¶é¢ï¼ˆæ— å…¶ä»–åŠŸèƒ½ï¼‰
        vtk_face_visualization(parsed_data)`ã€‚">
<meta property="og:title" content="draw wrl with vtk">
<meta property="og:description" content="# point
```
import vtk
import re
import numpy as np

# -------------------------- é…ç½®å‚æ•°ï¼ˆæ–°å¢ç‚¹å¤§å°è®¾ç½®ï¼‰ --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
POINT_SIZE = 5.0  # é¡¶ç‚¹å¤§å°ï¼ˆå¯è°ƒæ•´ï¼Œè¶Šå¤§è¶Šæ¸…æ™°ï¼‰
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯

# -------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æé€»è¾‘ä¸å˜ï¼ˆä»æå–é¡¶ç‚¹æ•°æ®ï¼‰ --------------------------
def parse_vrml_manual(vrml_path):
    '''æ‰‹åŠ¨è§£æVRMLï¼Œæå–é¡¶ç‚¹ã€é¢œè‰²ç­‰æ•°æ®ï¼ˆè§£æé€»è¾‘ä¸å˜ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ ç´¢å¼•ï¼‰
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
        .*?point\s*\[\s*(.*?)\s*\]
        .*?coordIndex\s*\[\s*(.*?)\s*\]
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)
    
    if not matches:
        print('âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...')
        pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
        matches = re.findall(pattern_simple, content, re.DOTALL)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
        if len(match) == 6:
            seg_id, r, g, b, point_str, coord_idx_str = match
        else:
            seg_id, r, g, b, point_str = match
            coord_idx_str = ''
        
        # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
        r, g, b = float(r), float(g), float(b)
        if r > 0.7 and g < 0.1 and b > 0.7:
            rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
        elif r > 0.9 and g < 0.1 and b < 0.1:
            rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
        else:
            rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
        
        # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
        points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
        
        # ä»…ä¿ç•™æœ‰é¡¶ç‚¹çš„æ•°æ®ï¼ˆè‡³å°‘1ä¸ªé¡¶ç‚¹å³å¯ï¼‰
        if len(points) >= 1:
            parsed_data.append({
                'seg_id': seg_id,
                'rgb': rgb,
                'points': points
            })
    
    return parsed_data

# -------------------------- æ ¸å¿ƒé€»è¾‘ï¼šä»…æ¸²æŸ“é¡¶ç‚¹ï¼ˆä¸è¿æ¥çº¿æ®µï¼‰ --------------------------
def vtk_render_points_only(parsed_data):
    '''çº¯é¡¶ç‚¹æ¸²æŸ“ï¼Œä¸æ„å»ºä»»ä½•çº¿æ®µ'''
    vtk_poly_data = vtk.vtkPolyData()
    vtk_points = vtk.vtkPoints()
    vtk_vertices = vtk.vtkCellArray()  # ç”¨äºå­˜å‚¨é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„vtkLinesï¼‰
    color_map = vtk.vtkUnsignedCharArray()
    color_map.SetNumberOfComponents(3)
    color_map.SetName('Colors')

    # éå†è§£ææ•°æ®ï¼Œæ·»åŠ æ‰€æœ‰é¡¶ç‚¹ï¼ˆä¸å¤„ç†è¿æ¥å…³ç³»ï¼‰
    for seg in parsed_data:
        points = seg['points']
        rgb = seg['rgb']

        # é€ä¸ªæ·»åŠ é¡¶ç‚¹å’Œå¯¹åº”çš„é¢œè‰²
        for x, y, z in points:
            # æ·»åŠ é¡¶ç‚¹åæ ‡
            point_id = vtk_points.InsertNextPoint(x, y, z)
            # æ·»åŠ é¡¶ç‚¹é¢œè‰²
            color_map.InsertNextTuple3(*rgb)
            # åˆ›å»ºå•ä¸ªé¡¶ç‚¹å•å…ƒï¼ˆå…³é”®ï¼šæ¯ä¸ªç‚¹ä½œä¸ºç‹¬ç«‹å•å…ƒï¼‰
            vertex = vtk.vtkVertex()
            vertex.GetPointIds().SetId(0, point_id)
            vtk_vertices.InsertNextCell(vertex)

    # ç»„è£…VTKæ•°æ®ï¼ˆç”¨é¡¶ç‚¹å•å…ƒæ›¿æ¢çº¿æ®µå•å…ƒï¼‰
    vtk_poly_data.SetPoints(vtk_points)
    vtk_poly_data.SetVerts(vtk_vertices)  # æ¸²æŸ“é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„SetLinesï¼‰
    vtk_poly_data.GetPointData().SetScalars(color_map)

    # é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé‡ç‚¹è®¾ç½®ç‚¹å¤§å°ï¼‰
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(vtk_poly_data)
    mapper.ScalarVisibilityOn()  # å¯ç”¨é¢œè‰²æ˜ å°„

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetPointSize(POINT_SIZE)  # è®¾ç½®é¡¶ç‚¹å¤§å°ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰

    # æ¸²æŸ“å™¨é…ç½®
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(*BACKGROUND_COLOR)
    renderer.ResetCamera()  # è‡ªåŠ¨è°ƒæ•´è§†è§’ä»¥åŒ…å«æ‰€æœ‰ç‚¹

    # çª—å£é…ç½®
    render_window = vtk.vtkRenderWindow()
    render_window.SetWindowName('ç¥ç»ç»†ä¸é¡¶ç‚¹å¯è§†åŒ–ï¼ˆä»…æ˜¾ç¤ºç‚¹ï¼‰')
    render_window.SetSize(1200, 900)
    render_window.AddRenderer(renderer)

    # äº¤äº’å™¨é…ç½®
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    # å¯åŠ¨å¯è§†åŒ–
    interactor.Initialize()
    render_window.Render()
    print('ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š')
    print('   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯')
    print('   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢')
    print('   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯')
    print('   - æŒ‰ 'q' é”®å…³é—­çª—å£')
    interactor.Start()

# -------------------------- ä¸»æ‰§è¡Œæµç¨‹ --------------------------
# 1. è§£æVRMLï¼ˆæå–é¡¶ç‚¹æ•°æ®ï¼‰
print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
parsed_data = parse_vrml_manual(VRML_FILE_PATH)

if not parsed_data:
    print('âŒ æœªæå–åˆ°æœ‰æ•ˆé¡¶ç‚¹æ•°æ®ï¼')
else:
    # ç»Ÿè®¡æ€»é¡¶ç‚¹æ•°
    total_points = sum(len(seg['points']) for seg in parsed_data)
    print(f'âœ… æˆåŠŸè§£æ {len(parsed_data)} ä¸ªçº¿æ®µï¼Œå…± {total_points} ä¸ªé¡¶ç‚¹ï¼Œå¯åŠ¨é¡¶ç‚¹å¯è§†åŒ–...')
    # 2. ä»…æ¸²æŸ“é¡¶ç‚¹
    vtk_render_points_only(parsed_data)
```



# lines

`import re
import numpy as np
import json
from pathlib import Path
import os

# -------------------------- é…ç½®å‚æ•° --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
EXPORT_FORMAT = 'json'  # å¯¼å‡ºæ ¼å¼ï¼š'json'ï¼ˆæ¨èï¼Œä¿ç•™ç»“æ„ï¼‰æˆ– 'txt'ï¼ˆæ˜“è¯»ï¼‰
DEFAULT_COLOR = (128, 128, 128)  # æ— diffuseColoræ—¶çš„é»˜è®¤é¢œè‰²

# -------------------------- æ ¸å¿ƒè§£æå‡½æ•°ï¼ˆä¿ç•™æ‰€æœ‰ç‰¹å¾ï¼‰ --------------------------
def parse_vrml_manual(vrml_path):
    '''è§£æVRMLï¼Œæå–æ‰€æœ‰FilamentSegmentçš„å®Œæ•´ç‰¹å¾ï¼ˆé€‚é…IndexedFaceSetç»“æ„ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # ç²¾å‡†åŒ¹é…ï¼šFilamentSegment â†’ diffuseColor â†’ IndexedFaceSet â†’ Coordinate(point) + coordIndex
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?
        (diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*)?  # é¢œè‰²ï¼ˆå¯é€‰ï¼‰
        .*?
        IndexedFaceSet\s*\{\s*
        .*?
        (coord\s+DEF\s+(\w+)\s+Coordinate\s*\{\s*point\s*\[\s*(.*?)\s*\]\s*\}\s*)  # CoordinateèŠ‚ç‚¹ï¼ˆå«pointï¼‰
        .*?
        (normal\s+DEF\s+(\w+)\s+Normal\s*\{\s*vector\s*(.*?)\s*\}\s*)?  # NormalèŠ‚ç‚¹ï¼ˆå¯é€‰ï¼Œå«æ³•å‘é‡ï¼‰
        .*?
        (coordIndex\s*\[\s*(.*?)\s*\])  # coordIndexï¼ˆé¢ç´¢å¼•ï¼‰
        .*?
        (normalIndex\s*\[\s*(.*?)\s*\])?  # normalIndexï¼ˆå¯é€‰ï¼‰
        .*?
        (ccw\s+(\w+))?\s*  # ccwå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (solid\s+(\w+))?\s*  # solidå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (convex\s+(\w+))?\s*  # convexå‚æ•°ï¼ˆå¯é€‰ï¼‰
        (creaseAngle\s+(\d+\.?\d*))?\s*  # creaseAngleå‚æ•°ï¼ˆå¯é€‰ï¼‰
        .*?\}\s*  # å…³é—­IndexedFaceSet
        .*?\}\s*  # å…³é—­FilamentSegment Group
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE | re.IGNORECASE)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆæŒ‰æ­£åˆ™åˆ†ç»„é¡ºåºï¼‰
        (diffuseColor_block, r, g, b,
         coord_block, coord_def_id, point_str,
         normal_block, normal_def_id, normal_vector_str,
         coordIndex_block, coord_idx_str,
         normalIndex_block, normal_idx_str,
         ccw_block, ccw_val,
         solid_block, solid_val,
         convex_block, convex_val,
         creaseAngle_block, creaseAngle_val) = match
        
        # 1. åŸºç¡€ä¿¡æ¯ï¼ˆFilamentSegment IDï¼‰
        seg_id = re.search(r'FilamentSegment\d+', match[0]).group() if match[0] else 'Unknown_Segment'
        
        # 2. é¢œè‰²ä¿¡æ¯
        if diffuseColor_block:
            r, g, b = float(r), float(g), float(b)
            rgb_255 = (int(r*255), int(g*255), int(b*255))
            # ç»“æ„ç±»å‹åˆ†ç±»
            if r > 0.7 and g < 0.1 and b > 0.7:
                color_desc = 'æ ‘çªï¼ˆç´«è‰²ï¼‰'
            elif r > 0.9 and g < 0.1 and b < 0.1:
                color_desc = 'è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰'
            else:
                color_desc = 'å…¶ä»–ç»“æ„'
        else:
            rgb_255 = DEFAULT_COLOR
            r, g, b = [c/255 for c in DEFAULT_COLOR]
            color_desc = 'æ— é¢œè‰²ä¿¡æ¯'
        
        # 3. é¡¶ç‚¹åæ ‡ï¼ˆCoordinate â†’ pointï¼‰
        points_raw = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points_raw, dtype=np.float64).reshape(-1, 3) if points_raw else np.array([])
        vertex_count = len(points)
        
        # 4. æ³•å‘é‡ä¿¡æ¯ï¼ˆNormal â†’ vectorï¼‰
        normal_vector = None
        if normal_block:
            normal_raw = re.findall(r'[-+]?\d+\.?\d*', normal_vector_str)
            normal_vector = tuple(map(float, normal_raw)) if len(normal_raw) == 3 else None
        
        # 5. é¢ç´¢å¼•ï¼ˆcoordIndexï¼‰
        coord_idx_groups = []
        if coord_idx_str.strip():
            idx_groups = re.split(r'-1\s*', coord_idx_str.strip())
            for group in idx_groups:
                if group.strip():
                    face_indices = [int(x) for x in group.split()]
                    if len(set(face_indices)) >= 3:  # è¿‡æ»¤æ— æ•ˆé¢
                        coord_idx_groups.append(face_indices)
        face_count = len(coord_idx_groups)
        
        # 6. å…¶ä»–IndexedFaceSetå‚æ•°
        ccw = ccw_val.lower() if ccw_val else 'true'  # é»˜è®¤true
        solid = solid_val.lower() if solid_val else 'false'  # é»˜è®¤false
        convex = convex_val.lower() if convex_val else 'true'  # é»˜è®¤true
        crease_angle = float(creaseAngle_val) if creaseAngle_val else 0.0
        
        # 7. normalIndexï¼ˆå¯é€‰ï¼‰
        normal_idx_groups = []
        if normalIndex_block and normal_idx_str.strip():
            idx_groups = re.split(r'-1\s*', normal_idx_str.strip())
            for group in idx_groups:
                if group.strip():
                    normal_idx_groups.append([int(x) for x in group.split()])
        
        # æ•´ç†æ‰€æœ‰ç‰¹å¾
        parsed_data.append({
            'åŸºç¡€ä¿¡æ¯': {
                'FilamentSegment ID': seg_id,
                'ç»“æ„ç±»å‹': color_desc,
                'é¡¶ç‚¹æ€»æ•°': vertex_count,
                'æœ‰æ•ˆé¢æ€»æ•°': face_count
            },
            'é¢œè‰²ä¿¡æ¯': {
                'åŸå§‹RGB(0-1)': (round(r, 6), round(g, 6), round(b, 6)),
                'æ ‡å‡†åŒ–RGB(0-255)': rgb_255,
                'é¢œè‰²æè¿°': color_desc
            },
            'CoordinateèŠ‚ç‚¹': {
                'DEF ID': coord_def_id,
                'é¡¶ç‚¹åæ ‡(point)': points.tolist(),  # è½¬ä¸ºlistæ–¹ä¾¿å¯¼å‡º
                'é¡¶ç‚¹æ€»æ•°': vertex_count
            },
            'NormalèŠ‚ç‚¹': {
                'DEF ID': normal_def_id if normal_def_id else 'æ— ',
                'æ³•å‘é‡(vector)': normal_vector,
                'æ˜¯å¦å­˜åœ¨æ³•å‘é‡': bool(normal_block)
            },
            'IndexedFaceSetå‚æ•°': {
                'coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰': coord_idx_groups,
                'normalIndexï¼ˆæ³•å‘é‡ç´¢å¼•ç»„ï¼‰': normal_idx_groups if normal_idx_groups else 'æ— ',
                'ccwï¼ˆé€†æ—¶é’ˆæ’åºï¼‰': ccw,
                'solidï¼ˆæ˜¯å¦ä¸ºå®å¿ƒï¼‰': solid,
                'convexï¼ˆæ˜¯å¦å‡¸å¤šè¾¹å½¢ï¼‰': convex,
                'creaseAngleï¼ˆæŠ˜ç—•è§’åº¦ï¼‰': round(crease_angle, 6)
            }
        })
    
    return parsed_data

# -------------------------- å·¥å…·å‡½æ•°ï¼šæˆªæ–­é•¿å‚æ•°æ˜¾ç¤º --------------------------
def truncate_long_data(data, max_lines=3):
    '''é•¿åˆ—è¡¨/æ•°ç»„æ˜¾ç¤ºæ—¶ä»…ä¿ç•™å‰max_linesè¡Œï¼Œç»“å°¾æ ‡æ³¨æ€»æ•°'''
    if isinstance(data, list):
        # å¤„ç†é¡¶ç‚¹åæ ‡ï¼ˆæ¯ä¸ªå…ƒç´ æ˜¯[x,y,z]ï¼‰
        if len(data) == 0:
            return 'æ— '
        elif len(data) <= max_lines:
            return [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data]
        else:
            truncated = [f'[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]' for x, y, z in data[:max_lines]]
            truncated.append(f'...ï¼ˆå…±{len(data)}ä¸ªé¡¶ç‚¹ï¼‰')
            return truncated
    elif isinstance(data, list) and all(isinstance(item, list) for item in data):
        # å¤„ç†ç´¢å¼•ç»„ï¼ˆå¦‚coordIndex_groupsï¼‰
        if len(data) == 0:
            return 'æ— '
        elif len(data) <= max_lines:
            return [str(group) for group in data]
        else:
            truncated = [str(group) for group in data[:max_lines]]
            truncated.append(f'...ï¼ˆå…±{len(data)}ä¸ªé¢ç´¢å¼•ç»„ï¼‰')
            return truncated
    else:
        return data

# -------------------------- æ ¸å¿ƒåŠŸèƒ½ï¼šå¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegment --------------------------
def export_first_segment_features(parsed_data):
    if not parsed_data:
        print('âŒ æœªè§£æåˆ°ä»»ä½•FilamentSegmentæ•°æ®ï¼')
        return
    
    # ä»…å–ç¬¬ä¸€ä¸ªFilamentSegment
    first_seg = parsed_data[0]
    seg_id = first_seg['åŸºç¡€ä¿¡æ¯']['FilamentSegment ID']
    print(f'ğŸ‰ å¼€å§‹å¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegmentç‰¹å¾ï¼š{seg_id}\n')

    # -------------------------- 1. æ§åˆ¶å°æ‰“å°ï¼ˆç®€åŒ–é•¿å‚æ•°ï¼‰ --------------------------
    print('='*60)
    print('ğŸ“‹ ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ï¼ˆé•¿å‚æ•°ä»…æ˜¾ç¤ºå‰3è¡Œï¼‰')
    print('='*60)
    
    for category, features in first_seg.items():
        print(f'\nã€{category}ã€‘')
        for key, value in features.items():
            # å¯¹é•¿å‚æ•°è¿›è¡Œæˆªæ–­æ˜¾ç¤º
            if key in ['é¡¶ç‚¹åæ ‡(point)', 'coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰']:
                truncated_val = truncate_long_data(value)
                if isinstance(truncated_val, list):
                    print(f'  {key}:')
                    for line in truncated_val:
                        print(f'    - {line}')
                else:
                    print(f'  {key}: {truncated_val}')
            else:
                print(f'  {key}: {value}')
    
    # -------------------------- 2. å¯¼å‡ºå®Œæ•´æ•°æ®åˆ°æ–‡ä»¶ --------------------------
    # ç”Ÿæˆå¯¼å‡ºè·¯å¾„
    vrml_dir = os.path.dirname(VRML_FILE_PATH)
    vrml_filename = Path(VRML_FILE_PATH).stem
    export_filename = f'{vrml_filename}_ç¬¬ä¸€ä¸ªFilamentSegment_å®Œæ•´ç‰¹å¾.{EXPORT_FORMAT}'
    export_path = os.path.join(vrml_dir, export_filename)
    
    # å¯¼å‡ºä¸ºJSONï¼ˆä¿ç•™å®Œæ•´ç»“æ„ï¼‰æˆ–TXTï¼ˆæ˜“è¯»ï¼‰
    if EXPORT_FORMAT == 'json':
        # è½¬æ¢numpyæ•°ç»„ä¸ºlistï¼ˆJSONä¸æ”¯æŒnumpyç±»å‹ï¼‰
        with open(export_path, 'w', encoding='utf-8') as f:
            json.dump(first_seg, f, ensure_ascii=False, indent=2)
    elif EXPORT_FORMAT == 'txt':
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(f'ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ - {seg_id}\n')
            f.write('='*80 + '\n\n')
            for category, features in first_seg.items():
                f.write(f'ã€{category}ã€‘\n')
                for key, value in features.items():
                    f.write(f'  {key}: {value}\n')
                f.write('\n')
    
    print(f'\nğŸ“ å®Œæ•´ç‰¹å¾å·²å¯¼å‡ºè‡³ï¼š{export_path}')
    print(f'ğŸ’¡ å¯¼å‡ºæ ¼å¼ï¼š{EXPORT_FORMAT}ï¼ˆå«æœªæˆªæ–­çš„å®Œæ•´æ•°æ®ï¼‰')

# -------------------------- ä¸»å‡½æ•° --------------------------
if __name__ == '__main__':
    print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
    parsed_data = parse_vrml_manual(VRML_FILE_PATH)
    
    if parsed_data:
        print(f'âœ… å…±è§£æåˆ° {len(parsed_data)} ä¸ªFilamentSegment')
        export_first_segment_features(parsed_data)
    else:
        print('âŒ è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„FilamentSegmentç»“æ„ï¼')`
# faces
`import vtk
import re
import numpy as np

# -------------------------- é…ç½®å‚æ•°ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼Œä¿ç•™æ ¸å¿ƒé¡¹ï¼‰ --------------------------
VRML_FILE_PATH = r'C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl'
FACE_OPACITY = 0.7  # é¢é€æ˜åº¦ï¼ˆ0=é€æ˜ï¼Œ1=ä¸é€æ˜ï¼‰
EDGE_WIDTH = 1.0    # é¢è¾¹ç¼˜å®½åº¦ï¼ˆçªå‡ºé¢è¾¹ç•Œï¼‰
EDGE_COLOR = (0.0, 0.0, 0.0)  # é¢è¾¹ç¼˜é¢œè‰²ï¼ˆé»‘è‰²ï¼‰
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯

# -------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æcoordIndexå¹¶ä¿ç•™-1ä½œä¸ºé¢åˆ†éš”ç¬¦ --------------------------
def parse_vrml_manual(vrml_path):
    '''æ‰‹åŠ¨è§£æVRMLï¼Œä¿ç•™coordIndexä¸­çš„-1ï¼Œæå–é¢æ•°æ®ï¼ˆIDã€é¢œè‰²ã€é¡¶ç‚¹ã€é¢ç´¢å¼•ç»„ï¼‰'''
    with open(vrml_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ å¸¦-1çš„coordIndexï¼‰
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
        .*?point\s*\[\s*(.*?)\s*\]
        .*?coordIndex\s*\[\s*(.*?)\s*\]
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)
    
    if not matches:
        print('âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...')
        pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
        matches = re.findall(pattern_simple, content, re.DOTALL)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
        if len(match) == 6:
            seg_id, r, g, b, point_str, coord_idx_str = match
        else:
            seg_id, r, g, b, point_str = match
            coord_idx_str = ''
        
        # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
        r, g, b = float(r), float(g), float(b)
        if r > 0.7 and g < 0.1 and b > 0.7:
            rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
        elif r > 0.9 and g < 0.1 and b < 0.1:
            rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
        else:
            rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
        
        # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
        points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
        
        # -------------------------- å…³é”®ä¿®æ”¹ï¼šä¿ç•™-1ï¼ŒæŒ‰-1åˆ†å‰²é¢ç´¢å¼• --------------------------
        face_groups = []
        if coord_idx_str.strip():
            # æ­¥éª¤1ï¼šç§»é™¤é€—å·ï¼ˆå¤„ç†'0,1,18,17,-1' â†’ '0 1 18 17 -1'ï¼‰
            coord_idx_str_clean = coord_idx_str.replace(',', '').strip()
            # æ­¥éª¤2ï¼šæŒ‰-1åˆ†å‰²ï¼Œå¾—åˆ°æ¯ä¸ªé¢çš„ç´¢å¼•ç»„ï¼ˆä¿ç•™-1ä½œä¸ºåˆ†éš”ç¬¦ï¼Œåˆ†å‰²åä¸¢å¼ƒ-1ï¼‰
            idx_groups = re.split(r'-1\s*', coord_idx_str_clean)
            # æ­¥éª¤3ï¼šè¿‡æ»¤ç©ºç»„ï¼Œä¸”æ¯ä¸ªé¢éœ€â‰¥3ä¸ªé¡¶ç‚¹æ‰æœ‰æ•ˆ
            for group in idx_groups:
                if group.strip():
                    face_indices = [int(x) for x in group.split()]
                    if len(face_indices) >= 3:  # é¢è‡³å°‘éœ€è¦3ä¸ªé¡¶ç‚¹
                        face_groups.append(face_indices)
        
        # ä»…ä¿ç•™æœ‰æ•ˆæ•°æ®ï¼ˆè‡³å°‘3ä¸ªé¡¶ç‚¹ + è‡³å°‘1ä¸ªæœ‰æ•ˆé¢ï¼‰
        if len(points) >= 3 and len(face_groups) >= 1:
            parsed_data.append({
                'seg_id': seg_id,
                'rgb': rgb,
                'points': points,
                'face_groups': face_groups  # å­˜å‚¨æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
            })
    
    return parsed_data

# -------------------------- æ ¸å¿ƒé€»è¾‘ï¼šVTKç»˜åˆ¶é¢ï¼ˆfaceï¼‰è€Œéçº¿ï¼ˆlineï¼‰ --------------------------
def vtk_face_visualization(parsed_data):
    '''ç”¨VTKç»˜åˆ¶3Dé¢ï¼Œä¿ç•™é¢è¾¹ç¼˜ï¼Œæ— å†—ä½™åŠŸèƒ½'''
    vtk_poly_data = vtk.vtkPolyData()
    vtk_points = vtk.vtkPoints()
    vtk_faces = vtk.vtkCellArray()  # å­˜å‚¨é¢ï¼ˆæ›¿æ¢åŸvtkLinesï¼‰
    color_map = vtk.vtkUnsignedCharArray()
    color_map.SetNumberOfComponents(3)
    color_map.SetName('Colors')

    # éå†è§£ææ•°æ®ï¼Œæ„å»ºVTKé¡¶ç‚¹å’Œé¢
    for seg in parsed_data:
        points = seg['points']
        face_groups = seg['face_groups']  # æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
        rgb = seg['rgb']

        # æ·»åŠ é¡¶ç‚¹å’Œé¢œè‰²ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
        start_point_id = vtk_points.GetNumberOfPoints()
        for x, y, z in points:
            vtk_points.InsertNextPoint(x, y, z)
            color_map.InsertNextTuple3(*rgb)

        # -------------------------- å…³é”®ä¿®æ”¹ï¼šç”¨vtkPolygonåˆ›å»ºé¢ï¼ˆæ›¿æ¢åŸvtkLineï¼‰ --------------------------
        for face_indices in face_groups:
            # åˆ›å»ºå•ä¸ªé¢ï¼ˆå¤šè¾¹å½¢ï¼‰
            polygon = vtk.vtkPolygon()
            polygon.GetPointIds().SetNumberOfIds(len(face_indices))
            # æ˜ å°„å±€éƒ¨ç´¢å¼•åˆ°å…¨å±€é¡¶ç‚¹ID
            for i, idx in enumerate(face_indices):
                global_point_id = start_point_id + idx
                polygon.GetPointIds().SetId(i, global_point_id)
            # æ·»åŠ é¢åˆ°é¢æ•°ç»„
            vtk_faces.InsertNextCell(polygon)

    # ç»„è£…VTKæ•°æ®ï¼ˆç”¨SetPolysæ›¿æ¢åŸSetLinesï¼‰
    vtk_poly_data.SetPoints(vtk_points)
    vtk_poly_data.SetPolys(vtk_faces)  # ç»˜åˆ¶é¢ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰
    vtk_poly_data.GetPointData().SetScalars(color_map)

    # é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼‰
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(vtk_poly_data)
    mapper.ScalarVisibilityOn()

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    # é¢æ¸²æŸ“å±æ€§ï¼ˆé€æ˜åº¦+è¾¹ç¼˜ï¼‰
    actor.GetProperty().SetOpacity(FACE_OPACITY)
    actor.GetProperty().SetEdgeVisibility(True)  # æ˜¾ç¤ºé¢è¾¹ç¼˜
    actor.GetProperty().SetEdgeColor(*EDGE_COLOR)  # è¾¹ç¼˜é¢œè‰²
    actor.GetProperty().SetLineWidth(EDGE_WIDTH)  # è¾¹ç¼˜å®½åº¦

    # æ¸²æŸ“å™¨é…ç½®ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(*BACKGROUND_COLOR)
    renderer.ResetCamera()  # è‡ªåŠ¨é€‚é…æ‰€æœ‰é¢

    render_window = vtk.vtkRenderWindow()
    render_window.SetWindowName('ç¥ç»ç»†ä¸VTKé¢å¯è§†åŒ–')
    render_window.SetSize(1200, 900)
    render_window.AddRenderer(renderer)

    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    # å¯åŠ¨å¯è§†åŒ–äº¤äº’ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
    interactor.Initialize()
    render_window.Render()
    print('ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š')
    print('   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯')
    print('   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢')
    print('   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯')
    print('   - æŒ‰ 'q' é”®å…³é—­çª—å£')
    interactor.Start()

# -------------------------- ä¸»å‡½æ•°ï¼ˆçº¯é¢å¯è§†åŒ–æµç¨‹ï¼‰ --------------------------
if __name__ == '__main__':
    # 1. è§£æVRMLï¼ˆä¿ç•™-1ï¼Œæå–é¢æ•°æ®ï¼‰
    print('ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...')
    parsed_data = parse_vrml_manual(VRML_FILE_PATH)

    if not parsed_data:
        print('âŒ æœªæå–åˆ°æœ‰æ•ˆé¢æ•°æ®ï¼')
    else:
        total_segments = len(parsed_data)
        total_faces = sum(len(seg['face_groups']) for seg in parsed_data)
        total_points = sum(len(seg['points']) for seg in parsed_data)
        print(f'âœ… æˆåŠŸè§£æ {total_segments} ä¸ªç¥ç»ç»†ä¸æ®µï¼Œ{total_points} ä¸ªé¡¶ç‚¹ï¼Œ{total_faces} ä¸ªé¢ï¼Œå¯åŠ¨VTKé¢å¯è§†åŒ–...')
        # 2. VTKç»˜åˆ¶é¢ï¼ˆæ— å…¶ä»–åŠŸèƒ½ï¼‰
        vtk_face_visualization(parsed_data)`ã€‚">
<meta property="og:type" content="article">
<meta property="og:url" content="https://conanan.github.io/post/draw%20wrl%20with%20vtk.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>draw wrl with vtk</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">draw wrl with vtk</h1>
<div class="title-right">
    <a href="https://conanan.github.io" id="buttonHome" class="btn btn-invisible circle" title="é¦–é¡µ">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/conanan/conanan.github.io/issues/4" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="åˆ‡æ¢ä¸»é¢˜">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>point</h1>
<pre class="notranslate"><code class="notranslate">import vtk
import re
import numpy as np

# -------------------------- é…ç½®å‚æ•°ï¼ˆæ–°å¢ç‚¹å¤§å°è®¾ç½®ï¼‰ --------------------------
VRML_FILE_PATH = r"C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl"
POINT_SIZE = 5.0  # é¡¶ç‚¹å¤§å°ï¼ˆå¯è°ƒæ•´ï¼Œè¶Šå¤§è¶Šæ¸…æ™°ï¼‰
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯

# -------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æé€»è¾‘ä¸å˜ï¼ˆä»æå–é¡¶ç‚¹æ•°æ®ï¼‰ --------------------------
def parse_vrml_manual(vrml_path):
    """æ‰‹åŠ¨è§£æVRMLï¼Œæå–é¡¶ç‚¹ã€é¢œè‰²ç­‰æ•°æ®ï¼ˆè§£æé€»è¾‘ä¸å˜ï¼‰"""
    with open(vrml_path, "r", encoding="utf-8") as f:
        content = f.read()
    
    # æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ ç´¢å¼•ï¼‰
    pattern = r'''
        DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
        .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
        .*?point\s*\[\s*(.*?)\s*\]
        .*?coordIndex\s*\[\s*(.*?)\s*\]
    '''
    matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)
    
    if not matches:
        print("âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...")
        pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
        matches = re.findall(pattern_simple, content, re.DOTALL)
    
    parsed_data = []
    for match in matches:
        # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
        if len(match) == 6:
            seg_id, r, g, b, point_str, coord_idx_str = match
        else:
            seg_id, r, g, b, point_str = match
            coord_idx_str = ""
        
        # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
        r, g, b = float(r), float(g), float(b)
        if r &gt; 0.7 and g &lt; 0.1 and b &gt; 0.7:
            rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
        elif r &gt; 0.9 and g &lt; 0.1 and b &lt; 0.1:
            rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
        else:
            rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
        
        # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
        points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
        points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
        
        # ä»…ä¿ç•™æœ‰é¡¶ç‚¹çš„æ•°æ®ï¼ˆè‡³å°‘1ä¸ªé¡¶ç‚¹å³å¯ï¼‰
        if len(points) &gt;= 1:
            parsed_data.append({
                "seg_id": seg_id,
                "rgb": rgb,
                "points": points
            })
    
    return parsed_data

# -------------------------- æ ¸å¿ƒé€»è¾‘ï¼šä»…æ¸²æŸ“é¡¶ç‚¹ï¼ˆä¸è¿æ¥çº¿æ®µï¼‰ --------------------------
def vtk_render_points_only(parsed_data):
    """çº¯é¡¶ç‚¹æ¸²æŸ“ï¼Œä¸æ„å»ºä»»ä½•çº¿æ®µ"""
    vtk_poly_data = vtk.vtkPolyData()
    vtk_points = vtk.vtkPoints()
    vtk_vertices = vtk.vtkCellArray()  # ç”¨äºå­˜å‚¨é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„vtkLinesï¼‰
    color_map = vtk.vtkUnsignedCharArray()
    color_map.SetNumberOfComponents(3)
    color_map.SetName("Colors")

    # éå†è§£ææ•°æ®ï¼Œæ·»åŠ æ‰€æœ‰é¡¶ç‚¹ï¼ˆä¸å¤„ç†è¿æ¥å…³ç³»ï¼‰
    for seg in parsed_data:
        points = seg["points"]
        rgb = seg["rgb"]

        # é€ä¸ªæ·»åŠ é¡¶ç‚¹å’Œå¯¹åº”çš„é¢œè‰²
        for x, y, z in points:
            # æ·»åŠ é¡¶ç‚¹åæ ‡
            point_id = vtk_points.InsertNextPoint(x, y, z)
            # æ·»åŠ é¡¶ç‚¹é¢œè‰²
            color_map.InsertNextTuple3(*rgb)
            # åˆ›å»ºå•ä¸ªé¡¶ç‚¹å•å…ƒï¼ˆå…³é”®ï¼šæ¯ä¸ªç‚¹ä½œä¸ºç‹¬ç«‹å•å…ƒï¼‰
            vertex = vtk.vtkVertex()
            vertex.GetPointIds().SetId(0, point_id)
            vtk_vertices.InsertNextCell(vertex)

    # ç»„è£…VTKæ•°æ®ï¼ˆç”¨é¡¶ç‚¹å•å…ƒæ›¿æ¢çº¿æ®µå•å…ƒï¼‰
    vtk_poly_data.SetPoints(vtk_points)
    vtk_poly_data.SetVerts(vtk_vertices)  # æ¸²æŸ“é¡¶ç‚¹ï¼ˆæ›¿æ¢åŸæ¥çš„SetLinesï¼‰
    vtk_poly_data.GetPointData().SetScalars(color_map)

    # é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé‡ç‚¹è®¾ç½®ç‚¹å¤§å°ï¼‰
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(vtk_poly_data)
    mapper.ScalarVisibilityOn()  # å¯ç”¨é¢œè‰²æ˜ å°„

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.GetProperty().SetPointSize(POINT_SIZE)  # è®¾ç½®é¡¶ç‚¹å¤§å°ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰

    # æ¸²æŸ“å™¨é…ç½®
    renderer = vtk.vtkRenderer()
    renderer.AddActor(actor)
    renderer.SetBackground(*BACKGROUND_COLOR)
    renderer.ResetCamera()  # è‡ªåŠ¨è°ƒæ•´è§†è§’ä»¥åŒ…å«æ‰€æœ‰ç‚¹

    # çª—å£é…ç½®
    render_window = vtk.vtkRenderWindow()
    render_window.SetWindowName("ç¥ç»ç»†ä¸é¡¶ç‚¹å¯è§†åŒ–ï¼ˆä»…æ˜¾ç¤ºç‚¹ï¼‰")
    render_window.SetSize(1200, 900)
    render_window.AddRenderer(renderer)

    # äº¤äº’å™¨é…ç½®
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(render_window)

    # å¯åŠ¨å¯è§†åŒ–
    interactor.Initialize()
    render_window.Render()
    print("ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š")
    print("   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯")
    print("   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢")
    print("   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯")
    print("   - æŒ‰ 'q' é”®å…³é—­çª—å£")
    interactor.Start()

# -------------------------- ä¸»æ‰§è¡Œæµç¨‹ --------------------------
# 1. è§£æVRMLï¼ˆæå–é¡¶ç‚¹æ•°æ®ï¼‰
print("ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...")
parsed_data = parse_vrml_manual(VRML_FILE_PATH)

if not parsed_data:
    print("âŒ æœªæå–åˆ°æœ‰æ•ˆé¡¶ç‚¹æ•°æ®ï¼")
else:
    # ç»Ÿè®¡æ€»é¡¶ç‚¹æ•°
    total_points = sum(len(seg["points"]) for seg in parsed_data)
    print(f"âœ… æˆåŠŸè§£æ {len(parsed_data)} ä¸ªçº¿æ®µï¼Œå…± {total_points} ä¸ªé¡¶ç‚¹ï¼Œå¯åŠ¨é¡¶ç‚¹å¯è§†åŒ–...")
    # 2. ä»…æ¸²æŸ“é¡¶ç‚¹
    vtk_render_points_only(parsed_data)
</code></pre>
<h1>lines</h1>
<p>`import re<br>
import numpy as np<br>
import json<br>
from pathlib import Path<br>
import os</p>
<h1>-------------------------- é…ç½®å‚æ•° --------------------------</h1>
<p>VRML_FILE_PATH = r"C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl"<br>
EXPORT_FORMAT = "json"  # å¯¼å‡ºæ ¼å¼ï¼š"json"ï¼ˆæ¨èï¼Œä¿ç•™ç»“æ„ï¼‰æˆ– "txt"ï¼ˆæ˜“è¯»ï¼‰<br>
DEFAULT_COLOR = (128, 128, 128)  # æ— diffuseColoræ—¶çš„é»˜è®¤é¢œè‰²</p>
<h1>-------------------------- æ ¸å¿ƒè§£æå‡½æ•°ï¼ˆä¿ç•™æ‰€æœ‰ç‰¹å¾ï¼‰ --------------------------</h1>
<p>def parse_vrml_manual(vrml_path):<br>
"""è§£æVRMLï¼Œæå–æ‰€æœ‰FilamentSegmentçš„å®Œæ•´ç‰¹å¾ï¼ˆé€‚é…IndexedFaceSetç»“æ„ï¼‰"""<br>
with open(vrml_path, "r", encoding="utf-8") as f:<br>
content = f.read()</p>
<pre class="notranslate"><code class="notranslate"># ç²¾å‡†åŒ¹é…ï¼šFilamentSegment â†’ diffuseColor â†’ IndexedFaceSet â†’ Coordinate(point) + coordIndex
pattern = r'''
    DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
    .*?
    (diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*)?  # é¢œè‰²ï¼ˆå¯é€‰ï¼‰
    .*?
    IndexedFaceSet\s*\{\s*
    .*?
    (coord\s+DEF\s+(\w+)\s+Coordinate\s*\{\s*point\s*\[\s*(.*?)\s*\]\s*\}\s*)  # CoordinateèŠ‚ç‚¹ï¼ˆå«pointï¼‰
    .*?
    (normal\s+DEF\s+(\w+)\s+Normal\s*\{\s*vector\s*(.*?)\s*\}\s*)?  # NormalèŠ‚ç‚¹ï¼ˆå¯é€‰ï¼Œå«æ³•å‘é‡ï¼‰
    .*?
    (coordIndex\s*\[\s*(.*?)\s*\])  # coordIndexï¼ˆé¢ç´¢å¼•ï¼‰
    .*?
    (normalIndex\s*\[\s*(.*?)\s*\])?  # normalIndexï¼ˆå¯é€‰ï¼‰
    .*?
    (ccw\s+(\w+))?\s*  # ccwå‚æ•°ï¼ˆå¯é€‰ï¼‰
    (solid\s+(\w+))?\s*  # solidå‚æ•°ï¼ˆå¯é€‰ï¼‰
    (convex\s+(\w+))?\s*  # convexå‚æ•°ï¼ˆå¯é€‰ï¼‰
    (creaseAngle\s+(\d+\.?\d*))?\s*  # creaseAngleå‚æ•°ï¼ˆå¯é€‰ï¼‰
    .*?\}\s*  # å…³é—­IndexedFaceSet
    .*?\}\s*  # å…³é—­FilamentSegment Group
'''
matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE | re.IGNORECASE)

parsed_data = []
for match in matches:
    # è§£åŒ…åŒ¹é…ç»“æœï¼ˆæŒ‰æ­£åˆ™åˆ†ç»„é¡ºåºï¼‰
    (diffuseColor_block, r, g, b,
     coord_block, coord_def_id, point_str,
     normal_block, normal_def_id, normal_vector_str,
     coordIndex_block, coord_idx_str,
     normalIndex_block, normal_idx_str,
     ccw_block, ccw_val,
     solid_block, solid_val,
     convex_block, convex_val,
     creaseAngle_block, creaseAngle_val) = match
    
    # 1. åŸºç¡€ä¿¡æ¯ï¼ˆFilamentSegment IDï¼‰
    seg_id = re.search(r'FilamentSegment\d+', match[0]).group() if match[0] else "Unknown_Segment"
    
    # 2. é¢œè‰²ä¿¡æ¯
    if diffuseColor_block:
        r, g, b = float(r), float(g), float(b)
        rgb_255 = (int(r*255), int(g*255), int(b*255))
        # ç»“æ„ç±»å‹åˆ†ç±»
        if r &gt; 0.7 and g &lt; 0.1 and b &gt; 0.7:
            color_desc = "æ ‘çªï¼ˆç´«è‰²ï¼‰"
        elif r &gt; 0.9 and g &lt; 0.1 and b &lt; 0.1:
            color_desc = "è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰"
        else:
            color_desc = "å…¶ä»–ç»“æ„"
    else:
        rgb_255 = DEFAULT_COLOR
        r, g, b = [c/255 for c in DEFAULT_COLOR]
        color_desc = "æ— é¢œè‰²ä¿¡æ¯"
    
    # 3. é¡¶ç‚¹åæ ‡ï¼ˆCoordinate â†’ pointï¼‰
    points_raw = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
    points = np.array(points_raw, dtype=np.float64).reshape(-1, 3) if points_raw else np.array([])
    vertex_count = len(points)
    
    # 4. æ³•å‘é‡ä¿¡æ¯ï¼ˆNormal â†’ vectorï¼‰
    normal_vector = None
    if normal_block:
        normal_raw = re.findall(r'[-+]?\d+\.?\d*', normal_vector_str)
        normal_vector = tuple(map(float, normal_raw)) if len(normal_raw) == 3 else None
    
    # 5. é¢ç´¢å¼•ï¼ˆcoordIndexï¼‰
    coord_idx_groups = []
    if coord_idx_str.strip():
        idx_groups = re.split(r'-1\s*', coord_idx_str.strip())
        for group in idx_groups:
            if group.strip():
                face_indices = [int(x) for x in group.split()]
                if len(set(face_indices)) &gt;= 3:  # è¿‡æ»¤æ— æ•ˆé¢
                    coord_idx_groups.append(face_indices)
    face_count = len(coord_idx_groups)
    
    # 6. å…¶ä»–IndexedFaceSetå‚æ•°
    ccw = ccw_val.lower() if ccw_val else "true"  # é»˜è®¤true
    solid = solid_val.lower() if solid_val else "false"  # é»˜è®¤false
    convex = convex_val.lower() if convex_val else "true"  # é»˜è®¤true
    crease_angle = float(creaseAngle_val) if creaseAngle_val else 0.0
    
    # 7. normalIndexï¼ˆå¯é€‰ï¼‰
    normal_idx_groups = []
    if normalIndex_block and normal_idx_str.strip():
        idx_groups = re.split(r'-1\s*', normal_idx_str.strip())
        for group in idx_groups:
            if group.strip():
                normal_idx_groups.append([int(x) for x in group.split()])
    
    # æ•´ç†æ‰€æœ‰ç‰¹å¾
    parsed_data.append({
        "åŸºç¡€ä¿¡æ¯": {
            "FilamentSegment ID": seg_id,
            "ç»“æ„ç±»å‹": color_desc,
            "é¡¶ç‚¹æ€»æ•°": vertex_count,
            "æœ‰æ•ˆé¢æ€»æ•°": face_count
        },
        "é¢œè‰²ä¿¡æ¯": {
            "åŸå§‹RGB(0-1)": (round(r, 6), round(g, 6), round(b, 6)),
            "æ ‡å‡†åŒ–RGB(0-255)": rgb_255,
            "é¢œè‰²æè¿°": color_desc
        },
        "CoordinateèŠ‚ç‚¹": {
            "DEF ID": coord_def_id,
            "é¡¶ç‚¹åæ ‡(point)": points.tolist(),  # è½¬ä¸ºlistæ–¹ä¾¿å¯¼å‡º
            "é¡¶ç‚¹æ€»æ•°": vertex_count
        },
        "NormalèŠ‚ç‚¹": {
            "DEF ID": normal_def_id if normal_def_id else "æ— ",
            "æ³•å‘é‡(vector)": normal_vector,
            "æ˜¯å¦å­˜åœ¨æ³•å‘é‡": bool(normal_block)
        },
        "IndexedFaceSetå‚æ•°": {
            "coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰": coord_idx_groups,
            "normalIndexï¼ˆæ³•å‘é‡ç´¢å¼•ç»„ï¼‰": normal_idx_groups if normal_idx_groups else "æ— ",
            "ccwï¼ˆé€†æ—¶é’ˆæ’åºï¼‰": ccw,
            "solidï¼ˆæ˜¯å¦ä¸ºå®å¿ƒï¼‰": solid,
            "convexï¼ˆæ˜¯å¦å‡¸å¤šè¾¹å½¢ï¼‰": convex,
            "creaseAngleï¼ˆæŠ˜ç—•è§’åº¦ï¼‰": round(crease_angle, 6)
        }
    })

return parsed_data
</code></pre>
<h1>-------------------------- å·¥å…·å‡½æ•°ï¼šæˆªæ–­é•¿å‚æ•°æ˜¾ç¤º --------------------------</h1>
<p>def truncate_long_data(data, max_lines=3):<br>
"""é•¿åˆ—è¡¨/æ•°ç»„æ˜¾ç¤ºæ—¶ä»…ä¿ç•™å‰max_linesè¡Œï¼Œç»“å°¾æ ‡æ³¨æ€»æ•°"""<br>
if isinstance(data, list):<br>
# å¤„ç†é¡¶ç‚¹åæ ‡ï¼ˆæ¯ä¸ªå…ƒç´ æ˜¯[x,y,z]ï¼‰<br>
if len(data) == 0:<br>
return "æ— "<br>
elif len(data) &lt;= max_lines:<br>
return [f"[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]" for x, y, z in data]<br>
else:<br>
truncated = [f"[{round(x, 6)}, {round(y, 6)}, {round(z, 6)}]" for x, y, z in data[:max_lines]]<br>
truncated.append(f"...ï¼ˆå…±{len(data)}ä¸ªé¡¶ç‚¹ï¼‰")<br>
return truncated<br>
elif isinstance(data, list) and all(isinstance(item, list) for item in data):<br>
# å¤„ç†ç´¢å¼•ç»„ï¼ˆå¦‚coordIndex_groupsï¼‰<br>
if len(data) == 0:<br>
return "æ— "<br>
elif len(data) &lt;= max_lines:<br>
return [str(group) for group in data]<br>
else:<br>
truncated = [str(group) for group in data[:max_lines]]<br>
truncated.append(f"...ï¼ˆå…±{len(data)}ä¸ªé¢ç´¢å¼•ç»„ï¼‰")<br>
return truncated<br>
else:<br>
return data</p>
<h1>-------------------------- æ ¸å¿ƒåŠŸèƒ½ï¼šå¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegment --------------------------</h1>
<p>def export_first_segment_features(parsed_data):<br>
if not parsed_data:<br>
print("âŒ æœªè§£æåˆ°ä»»ä½•FilamentSegmentæ•°æ®ï¼")<br>
return</p>
<pre class="notranslate"><code class="notranslate"># ä»…å–ç¬¬ä¸€ä¸ªFilamentSegment
first_seg = parsed_data[0]
seg_id = first_seg["åŸºç¡€ä¿¡æ¯"]["FilamentSegment ID"]
print(f"ğŸ‰ å¼€å§‹å¯¼å‡ºç¬¬ä¸€ä¸ªFilamentSegmentç‰¹å¾ï¼š{seg_id}\n")

# -------------------------- 1. æ§åˆ¶å°æ‰“å°ï¼ˆç®€åŒ–é•¿å‚æ•°ï¼‰ --------------------------
print("="*60)
print("ğŸ“‹ ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ï¼ˆé•¿å‚æ•°ä»…æ˜¾ç¤ºå‰3è¡Œï¼‰")
print("="*60)

for category, features in first_seg.items():
    print(f"\nã€{category}ã€‘")
    for key, value in features.items():
        # å¯¹é•¿å‚æ•°è¿›è¡Œæˆªæ–­æ˜¾ç¤º
        if key in ["é¡¶ç‚¹åæ ‡(point)", "coordIndexï¼ˆé¢ç´¢å¼•ç»„ï¼‰"]:
            truncated_val = truncate_long_data(value)
            if isinstance(truncated_val, list):
                print(f"  {key}:")
                for line in truncated_val:
                    print(f"    - {line}")
            else:
                print(f"  {key}: {truncated_val}")
        else:
            print(f"  {key}: {value}")

# -------------------------- 2. å¯¼å‡ºå®Œæ•´æ•°æ®åˆ°æ–‡ä»¶ --------------------------
# ç”Ÿæˆå¯¼å‡ºè·¯å¾„
vrml_dir = os.path.dirname(VRML_FILE_PATH)
vrml_filename = Path(VRML_FILE_PATH).stem
export_filename = f"{vrml_filename}_ç¬¬ä¸€ä¸ªFilamentSegment_å®Œæ•´ç‰¹å¾.{EXPORT_FORMAT}"
export_path = os.path.join(vrml_dir, export_filename)

# å¯¼å‡ºä¸ºJSONï¼ˆä¿ç•™å®Œæ•´ç»“æ„ï¼‰æˆ–TXTï¼ˆæ˜“è¯»ï¼‰
if EXPORT_FORMAT == "json":
    # è½¬æ¢numpyæ•°ç»„ä¸ºlistï¼ˆJSONä¸æ”¯æŒnumpyç±»å‹ï¼‰
    with open(export_path, "w", encoding="utf-8") as f:
        json.dump(first_seg, f, ensure_ascii=False, indent=2)
elif EXPORT_FORMAT == "txt":
    with open(export_path, "w", encoding="utf-8") as f:
        f.write(f"ç¬¬ä¸€ä¸ªFilamentSegmentå®Œæ•´ç‰¹å¾ - {seg_id}\n")
        f.write("="*80 + "\n\n")
        for category, features in first_seg.items():
            f.write(f"ã€{category}ã€‘\n")
            for key, value in features.items():
                f.write(f"  {key}: {value}\n")
            f.write("\n")

print(f"\nğŸ“ å®Œæ•´ç‰¹å¾å·²å¯¼å‡ºè‡³ï¼š{export_path}")
print(f"ğŸ’¡ å¯¼å‡ºæ ¼å¼ï¼š{EXPORT_FORMAT}ï¼ˆå«æœªæˆªæ–­çš„å®Œæ•´æ•°æ®ï¼‰")
</code></pre>
<h1>-------------------------- ä¸»å‡½æ•° --------------------------</h1>
<p>if <strong>name</strong> == "<strong>main</strong>":<br>
print("ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...")<br>
parsed_data = parse_vrml_manual(VRML_FILE_PATH)</p>
<pre class="notranslate"><code class="notranslate">if parsed_data:
    print(f"âœ… å…±è§£æåˆ° {len(parsed_data)} ä¸ªFilamentSegment")
    export_first_segment_features(parsed_data)
else:
    print("âŒ è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„FilamentSegmentç»“æ„ï¼")`
</code></pre>
<h1>faces</h1>
<p>`import vtk<br>
import re<br>
import numpy as np</p>
<h1>-------------------------- é…ç½®å‚æ•°ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼Œä¿ç•™æ ¸å¿ƒé¡¹ï¼‰ --------------------------</h1>
<p>VRML_FILE_PATH = r"C:\Users\liuj2\Desktop\10_PDGF x GFP-M#170_Control RH_01x.wrl"<br>
FACE_OPACITY = 0.7  # é¢é€æ˜åº¦ï¼ˆ0=é€æ˜ï¼Œ1=ä¸é€æ˜ï¼‰<br>
EDGE_WIDTH = 1.0    # é¢è¾¹ç¼˜å®½åº¦ï¼ˆçªå‡ºé¢è¾¹ç•Œï¼‰<br>
EDGE_COLOR = (0.0, 0.0, 0.0)  # é¢è¾¹ç¼˜é¢œè‰²ï¼ˆé»‘è‰²ï¼‰<br>
BACKGROUND_COLOR = (1.0, 1.0, 1.0)  # ç™½è‰²èƒŒæ™¯</p>
<h1>-------------------------- æ ¸å¿ƒå·¥å…·ï¼šè§£æcoordIndexå¹¶ä¿ç•™-1ä½œä¸ºé¢åˆ†éš”ç¬¦ --------------------------</h1>
<p>def parse_vrml_manual(vrml_path):<br>
"""æ‰‹åŠ¨è§£æVRMLï¼Œä¿ç•™coordIndexä¸­çš„-1ï¼Œæå–é¢æ•°æ®ï¼ˆIDã€é¢œè‰²ã€é¡¶ç‚¹ã€é¢ç´¢å¼•ç»„ï¼‰"""<br>
with open(vrml_path, "r", encoding="utf-8") as f:<br>
content = f.read()</p>
<pre class="notranslate"><code class="notranslate"># æ­£åˆ™åŒ¹é…æ ¸å¿ƒæ•°æ®ï¼ˆFilamentSegment â†’ é¢œè‰² â†’ é¡¶ç‚¹ â†’ å¸¦-1çš„coordIndexï¼‰
pattern = r'''
    DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*
    .*?diffuseColor\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s*
    .*?point\s*\[\s*(.*?)\s*\]
    .*?coordIndex\s*\[\s*(.*?)\s*\]
'''
matches = re.findall(pattern, content, re.DOTALL | re.VERBOSE)

if not matches:
    print("âš ï¸  æœªåŒ¹é…åˆ°FilamentSegmentæ•°æ®ï¼Œå°è¯•ç®€åŒ–åŒ¹é…è§„åˆ™...")
    pattern_simple = r'DEF\s+(FilamentSegment\d+)\s+Group\s*\{\s*.*?diffuseColor\s+(\S+)\s+(\S+)\s+(\S+)\s*.*?point\s*\[\s*(.*?)\s*\]'
    matches = re.findall(pattern_simple, content, re.DOTALL)

parsed_data = []
for match in matches:
    # è§£åŒ…åŒ¹é…ç»“æœï¼ˆå…¼å®¹å®Œæ•´/ç®€åŒ–æ­£åˆ™ï¼‰
    if len(match) == 6:
        seg_id, r, g, b, point_str, coord_idx_str = match
    else:
        seg_id, r, g, b, point_str = match
        coord_idx_str = ""
    
    # è§£æé¢œè‰²ï¼ˆè½¬ä¸ºVTKæ‰€éœ€çš„0-255æ•´æ•°ï¼‰
    r, g, b = float(r), float(g), float(b)
    if r &gt; 0.7 and g &lt; 0.1 and b &gt; 0.7:
        rgb = (192, 0, 192)  # æ ‘çªï¼ˆç´«è‰²ï¼‰
    elif r &gt; 0.9 and g &lt; 0.1 and b &lt; 0.1:
        rgb = (255, 0, 0)    # è„ŠæŸ±ï¼ˆçº¢è‰²ï¼‰
    else:
        rgb = (128, 128, 128)  # å…¶ä»–ç»“æ„ï¼ˆç°è‰²ï¼‰
    
    # è§£æé¡¶ç‚¹åæ ‡ï¼ˆè½¬ä¸º(n,3)æ•°ç»„ï¼‰
    points = re.findall(r'[-+]?\d+\.?\d*e?[-+]?\d*', point_str)
    points = np.array(points, dtype=np.float64).reshape(-1, 3) if points else np.array([])
    
    # -------------------------- å…³é”®ä¿®æ”¹ï¼šä¿ç•™-1ï¼ŒæŒ‰-1åˆ†å‰²é¢ç´¢å¼• --------------------------
    face_groups = []
    if coord_idx_str.strip():
        # æ­¥éª¤1ï¼šç§»é™¤é€—å·ï¼ˆå¤„ç†"0,1,18,17,-1" â†’ "0 1 18 17 -1"ï¼‰
        coord_idx_str_clean = coord_idx_str.replace(',', '').strip()
        # æ­¥éª¤2ï¼šæŒ‰-1åˆ†å‰²ï¼Œå¾—åˆ°æ¯ä¸ªé¢çš„ç´¢å¼•ç»„ï¼ˆä¿ç•™-1ä½œä¸ºåˆ†éš”ç¬¦ï¼Œåˆ†å‰²åä¸¢å¼ƒ-1ï¼‰
        idx_groups = re.split(r'-1\s*', coord_idx_str_clean)
        # æ­¥éª¤3ï¼šè¿‡æ»¤ç©ºç»„ï¼Œä¸”æ¯ä¸ªé¢éœ€â‰¥3ä¸ªé¡¶ç‚¹æ‰æœ‰æ•ˆ
        for group in idx_groups:
            if group.strip():
                face_indices = [int(x) for x in group.split()]
                if len(face_indices) &gt;= 3:  # é¢è‡³å°‘éœ€è¦3ä¸ªé¡¶ç‚¹
                    face_groups.append(face_indices)
    
    # ä»…ä¿ç•™æœ‰æ•ˆæ•°æ®ï¼ˆè‡³å°‘3ä¸ªé¡¶ç‚¹ + è‡³å°‘1ä¸ªæœ‰æ•ˆé¢ï¼‰
    if len(points) &gt;= 3 and len(face_groups) &gt;= 1:
        parsed_data.append({
            "seg_id": seg_id,
            "rgb": rgb,
            "points": points,
            "face_groups": face_groups  # å­˜å‚¨æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
        })

return parsed_data
</code></pre>
<h1>-------------------------- æ ¸å¿ƒé€»è¾‘ï¼šVTKç»˜åˆ¶é¢ï¼ˆfaceï¼‰è€Œéçº¿ï¼ˆlineï¼‰ --------------------------</h1>
<p>def vtk_face_visualization(parsed_data):<br>
"""ç”¨VTKç»˜åˆ¶3Dé¢ï¼Œä¿ç•™é¢è¾¹ç¼˜ï¼Œæ— å†—ä½™åŠŸèƒ½"""<br>
vtk_poly_data = vtk.vtkPolyData()<br>
vtk_points = vtk.vtkPoints()<br>
vtk_faces = vtk.vtkCellArray()  # å­˜å‚¨é¢ï¼ˆæ›¿æ¢åŸvtkLinesï¼‰<br>
color_map = vtk.vtkUnsignedCharArray()<br>
color_map.SetNumberOfComponents(3)<br>
color_map.SetName("Colors")</p>
<pre class="notranslate"><code class="notranslate"># éå†è§£ææ•°æ®ï¼Œæ„å»ºVTKé¡¶ç‚¹å’Œé¢
for seg in parsed_data:
    points = seg["points"]
    face_groups = seg["face_groups"]  # æŒ‰-1åˆ†å‰²åçš„é¢ç´¢å¼•ç»„
    rgb = seg["rgb"]

    # æ·»åŠ é¡¶ç‚¹å’Œé¢œè‰²ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
    start_point_id = vtk_points.GetNumberOfPoints()
    for x, y, z in points:
        vtk_points.InsertNextPoint(x, y, z)
        color_map.InsertNextTuple3(*rgb)

    # -------------------------- å…³é”®ä¿®æ”¹ï¼šç”¨vtkPolygonåˆ›å»ºé¢ï¼ˆæ›¿æ¢åŸvtkLineï¼‰ --------------------------
    for face_indices in face_groups:
        # åˆ›å»ºå•ä¸ªé¢ï¼ˆå¤šè¾¹å½¢ï¼‰
        polygon = vtk.vtkPolygon()
        polygon.GetPointIds().SetNumberOfIds(len(face_indices))
        # æ˜ å°„å±€éƒ¨ç´¢å¼•åˆ°å…¨å±€é¡¶ç‚¹ID
        for i, idx in enumerate(face_indices):
            global_point_id = start_point_id + idx
            polygon.GetPointIds().SetId(i, global_point_id)
        # æ·»åŠ é¢åˆ°é¢æ•°ç»„
        vtk_faces.InsertNextCell(polygon)

# ç»„è£…VTKæ•°æ®ï¼ˆç”¨SetPolysæ›¿æ¢åŸSetLinesï¼‰
vtk_poly_data.SetPoints(vtk_points)
vtk_poly_data.SetPolys(vtk_faces)  # ç»˜åˆ¶é¢ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼‰
vtk_poly_data.GetPointData().SetScalars(color_map)

# é…ç½®VTKæ¸²æŸ“ç®¡çº¿ï¼ˆé€‚é…é¢æ¸²æŸ“ï¼‰
mapper = vtk.vtkPolyDataMapper()
mapper.SetInputData(vtk_poly_data)
mapper.ScalarVisibilityOn()

actor = vtk.vtkActor()
actor.SetMapper(mapper)
# é¢æ¸²æŸ“å±æ€§ï¼ˆé€æ˜åº¦+è¾¹ç¼˜ï¼‰
actor.GetProperty().SetOpacity(FACE_OPACITY)
actor.GetProperty().SetEdgeVisibility(True)  # æ˜¾ç¤ºé¢è¾¹ç¼˜
actor.GetProperty().SetEdgeColor(*EDGE_COLOR)  # è¾¹ç¼˜é¢œè‰²
actor.GetProperty().SetLineWidth(EDGE_WIDTH)  # è¾¹ç¼˜å®½åº¦

# æ¸²æŸ“å™¨é…ç½®ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(*BACKGROUND_COLOR)
renderer.ResetCamera()  # è‡ªåŠ¨é€‚é…æ‰€æœ‰é¢

render_window = vtk.vtkRenderWindow()
render_window.SetWindowName("ç¥ç»ç»†ä¸VTKé¢å¯è§†åŒ–")
render_window.SetSize(1200, 900)
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

# å¯åŠ¨å¯è§†åŒ–äº¤äº’ï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
interactor.Initialize()
render_window.Render()
print("ğŸ–±ï¸  äº¤äº’æŒ‡å—ï¼š")
print("   - å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬åœºæ™¯")
print("   - æ»šè½®ï¼šç¼©æ”¾ç”»é¢")
print("   - å³é”®æ‹–æ‹½ï¼šå¹³ç§»åœºæ™¯")
print("   - æŒ‰ 'q' é”®å…³é—­çª—å£")
interactor.Start()
</code></pre>
<h1>-------------------------- ä¸»å‡½æ•°ï¼ˆçº¯é¢å¯è§†åŒ–æµç¨‹ï¼‰ --------------------------</h1>
<p>if <strong>name</strong> == "<strong>main</strong>":<br>
# 1. è§£æVRMLï¼ˆä¿ç•™-1ï¼Œæå–é¢æ•°æ®ï¼‰<br>
print("ğŸ“¥ æ­£åœ¨è§£æVRMLæ–‡ä»¶...")<br>
parsed_data = parse_vrml_manual(VRML_FILE_PATH)</p>
<pre class="notranslate"><code class="notranslate">if not parsed_data:
    print("âŒ æœªæå–åˆ°æœ‰æ•ˆé¢æ•°æ®ï¼")
else:
    total_segments = len(parsed_data)
    total_faces = sum(len(seg["face_groups"]) for seg in parsed_data)
    total_points = sum(len(seg["points"]) for seg in parsed_data)
    print(f"âœ… æˆåŠŸè§£æ {total_segments} ä¸ªç¥ç»ç»†ä¸æ®µï¼Œ{total_points} ä¸ªé¡¶ç‚¹ï¼Œ{total_faces} ä¸ªé¢ï¼Œå¯åŠ¨VTKé¢å¯è§†åŒ–...")
    # 2. VTKç»˜åˆ¶é¢ï¼ˆæ— å…¶ä»–åŠŸèƒ½ï¼‰
    vtk_face_visualization(parsed_data)`
</code></pre></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">è¯„è®º</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright Â© <span id="copyrightYear"></span> <a href="https://conanan.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="ç½‘ç«™è¿è¡Œ"+diffDay+"å¤©"+" â€¢ ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","conanan/conanan.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
